<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Card Centering Tool v7.3.17</title>
<style>
  :root{
    --bg: #0b0f14;
    --panel: rgba(255,255,255,0.04);
    --panel2: rgba(255,255,255,0.06);
    --border: rgba(255,255,255,0.10);
    --text: rgba(255,255,255,0.92);
    --muted: rgba(255,255,255,0.65);
    --shadow: 0 18px 50px rgba(0,0,0,0.45);
    --accent: #31c7ff;
    --accent2: rgba(49,199,255,0.18);
    --danger: #ff6b6b;
    --warn: #ffce5c;
    --ok: #4cd964;
  }
  @media (prefers-color-scheme: light){
    :root{
      --bg: #f6f7fb;
      --panel: rgba(0,0,0,0.04);
      --panel2: rgba(0,0,0,0.06);
      --border: rgba(0,0,0,0.10);
      --text: rgba(0,0,0,0.88);
      --muted: rgba(0,0,0,0.55);
      --shadow: 0 18px 50px rgba(0,0,0,0.16);
      --accent: #0079ff;
      --accent2: rgba(0,121,255,0.14);
      --danger: #d63447;
      --warn: #b07700;
    }
  }

  *{ box-sizing:border-box; }
  html,body{height:100%; touch-action:none;}

  body{ height:100%; }
  html,body{ touch-action: none; }

  body{
    margin:0;
    background: radial-gradient(1200px 700px at 20% 0%, var(--accent2), transparent 60%) , var(--bg);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    overflow:hidden;
  }

  .app{
    height:100%;
    display:grid;
    grid-template-rows: 56px 1fr;
  }

  .topbar{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding: 10px 14px;
    border-bottom: 1px solid var(--border);
    backdrop-filter: blur(10px);
  }
  .brand{
    display:flex; align-items:center; gap:10px;
    font-weight:900; letter-spacing:0.3px;
  }
  .dot{
    width:10px; height:10px; border-radius:50%;
    background: var(--accent);
    box-shadow: 0 0 0 6px var(--accent2);
  }
  .top-actions{ display:flex; gap:10px; align-items:center; }
  .pill{
    font-size:12px;
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--border);
    background: var(--panel);
    color: var(--muted);
  }

  .btn{
    border:1px solid var(--border);
    background: var(--panel);
    color: var(--text);
    padding:8px 12px;
    border-radius:12px;
    font-weight:750;
    cursor:pointer;
    transition: transform .06s ease, background .15s ease;
    box-shadow: 0 10px 28px rgba(0,0,0,0.18);
  }
  .btn:hover{ background: var(--panel2); }
  .btn:active{ transform: translateY(1px); }
  .btn:disabled{ opacity:.45; cursor:not-allowed; box-shadow:none; }
  .ctrlDisabled{ opacity:.45; cursor:not-allowed; box-shadow:none; }
  .snapToggle.ctrlDisabled, .edgeAgg.ctrlDisabled{ pointer-events:none; }
  .edgeAgg input[type="range"]:disabled{ filter: grayscale(1); }

  .btn.primary{ border-color: transparent; background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06)); }
  .btn.accent{ border-color: rgba(255,255,255,0.0); background: linear-gradient(180deg, rgba(49,199,255,0.35), rgba(49,199,255,0.15)); }

  /* Upload button nudge: green glow when no image is loaded for the current side */
  #uploadBtn.needs-upload{
    border-color: rgba(76,217,100,0.55);
    box-shadow:
      0 0 0 2px rgba(76,217,100,0.28),
      0 0 18px rgba(76,217,100,0.28),
      0 10px 28px rgba(0,0,0,0.18);
    background: linear-gradient(180deg, rgba(76,217,100,0.20), rgba(76,217,100,0.08));
  }

  .btn.danger{ background: linear-gradient(180deg, rgba(255,107,107,0.25), rgba(255,107,107,0.10)); border-color: rgba(255,107,107,0.25); }
  .btn.ghost{ background: transparent; box-shadow:none; }

  .content{
    display:grid;
    grid-template-columns: 320px 1fr 360px;
    gap:14px;
    padding: 14px;
    min-height:0;
  }

  .panel{
    background: var(--panel);
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow: var(--shadow);
    min-height:0;
    overflow:hidden;
  }
  .panel-inner{
    padding:14px;
    height:100%;
    overflow:auto;
  }
  .section-title{
    font-size:12px;
    letter-spacing:0.18em;
    text-transform:uppercase;
    color: var(--muted);
    font-weight:900;
    margin: 6px 0 10px 0;
  }
  .card{
    background: rgba(255,255,255,0.03);
    border:1px solid var(--border);
    border-radius:16px;
    padding:12px;
  }

  .card.active-measure{
    background: rgba(49,199,255,0.10);
    border-color: rgba(49,199,255,0.38);
  }
  .card.active-geom{
    background: rgba(255,206,92,0.12);
    border-color: rgba(255,206,92,0.40);
  }

  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  .col{ display:flex; flex-direction:column; gap:10px; }

  select{
    width:100%;
    border-radius:12px;
    padding:10px 12px;
    background: rgba(0,0,0,0.10);
    border:1px solid var(--border);
    color: var(--text);
    font-weight:800;
    outline:none;
  }
  @media (prefers-color-scheme: light){
    select{ background: rgba(255,255,255,0.65); }
  }
  .hint{
    font-size:12px;
    color: var(--muted);
    line-height:1.35;
  }
  .status{
    white-space:pre-line;
    font-size:13px;
    line-height:1.35;
    color: var(--text);
  }
  .k{
    display:inline-flex; align-items:center; justify-content:center;
    padding:2px 8px;
    border-radius:8px;
    border:1px solid var(--border);
    background: rgba(255,255,255,0.03);
    font-weight:900;
    font-size:12px;
    margin:0 4px;
  }

  .canvas-wrap{
    cursor: crosshair;
    position:relative;
    width:100%;
    height:100%;
    overflow:hidden;
    border-radius:18px;
    background: rgba(0,0,0,0.15);
    border:1px solid var(--border);
    box-shadow: var(--shadow);
    touch-action: none; /* we handle pinch/pan ourselves */
  }

  /* --- Edge guidance glow (shows which side needs action) --- */
  .canvas-wrap{
    --edgeGlow: rgba(76, 217, 100, 0.95);
    --edgeGlowOuter: rgba(76, 217, 100, 0.55);
    --edgeStrip: 6px;
  }
  .canvas-wrap::after{
    content:"";
    position:absolute;
    pointer-events:none;
    opacity:0;
    z-index: 3;
    transition: opacity 140ms ease;
  }
  /* thin glowing strip, not a big overlay */
  .canvas-wrap.edge-left::after{
    opacity:1;
    top:0; bottom:0; left:0;
    width: var(--edgeStrip);
    border-radius:18px 0 0 18px;
    background: var(--edgeGlow);
    box-shadow: 0 0 16px var(--edgeGlowOuter), 0 0 34px rgba(76,217,100,0.25);
  }
  .canvas-wrap.edge-right::after{
    opacity:1;
    top:0; bottom:0; right:0;
    width: var(--edgeStrip);
    border-radius:0 18px 18px 0;
    background: var(--edgeGlow);
    box-shadow: 0 0 16px var(--edgeGlowOuter), 0 0 34px rgba(76,217,100,0.25);
  }
  .canvas-wrap.edge-top::after{
    opacity:1;
    left:0; right:0; top:0;
    height: var(--edgeStrip);
    border-radius:18px 18px 0 0;
    background: var(--edgeGlow);
    box-shadow: 0 0 16px var(--edgeGlowOuter), 0 0 34px rgba(76,217,100,0.25);
  }
  .canvas-wrap.edge-bottom::after{
    opacity:1;
    left:0; right:0; bottom:0;
    height: var(--edgeStrip);
    border-radius:0 0 18px 18px;
    background: var(--edgeGlow);
    box-shadow: 0 0 16px var(--edgeGlowOuter), 0 0 34px rgba(76,217,100,0.25);
  }
  .canvas-wrap.edge-all::after{
    opacity:1;
    inset:0;
    border-radius:18px;
    background: transparent;
    box-shadow: inset 0 0 0 3px rgba(76,217,100,0.75), 0 0 18px rgba(76,217,100,0.45), 0 0 38px rgba(76,217,100,0.22);
  }

  canvas{
    position:absolute;
    left:0; top:0;
    width:100%;
    height:100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }

  .toast{
    z-index: 6;
    position:absolute;
    left:12px;
    bottom:12px;
    padding:10px 12px;
    border-radius:14px;
    background: rgba(0,0,0,0.50);
    border: 1px solid rgba(255,255,255,0.18);
    color: rgba(255,255,255,0.92);
    font-weight:750;
    font-size:12px;
    box-shadow: 0 16px 45px rgba(0,0,0,0.35);
    max-width: 70%;
    display:none;
  }
  @media (prefers-color-scheme: light){
    .toast{
    z-index: 6;
      background: rgba(255,255,255,0.78);
      color: rgba(0,0,0,0.85);
      border-color: rgba(0,0,0,0.12);
    }
  }

  .metric{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:8px 12px;
    align-items:baseline;
    padding:12px;
    border-radius:16px;
    border:1px solid var(--border);
    background: rgba(255,255,255,0.03);
  }
  .metric .label{ color: var(--muted); font-weight:850; font-size:12px; letter-spacing:0.08em; text-transform:uppercase; }
  .metric .val{ font-weight:950; font-size:18px; }
  .metric .sub{ grid-column:1 / -1; font-size:12px; color: var(--muted); white-space:pre-line; }

  .divider{ height:1px; background: var(--border); margin: 10px 0; }




  .gradeGrid{ display:flex; flex-direction:column; gap:8px; margin-top:2px; }
  .gradeRow{ display:grid; grid-template-columns: 14px 1fr auto; align-items:center; gap:10px; }
  .lamp{
    width:12px; height:12px; border-radius:50%;
    background: rgba(255,255,255,0.18);
    border: 1px solid rgba(255,255,255,0.22);
    box-shadow: 0 0 0 6px rgba(255,255,255,0.04);
  }
  .lamp.ok{
    background: var(--ok);
    border-color: color-mix(in srgb, var(--ok) 70%, #000 30%);
    box-shadow: 0 0 0 6px color-mix(in srgb, var(--ok) 26%, transparent 74%), 0 0 18px color-mix(in srgb, var(--ok) 55%, transparent 45%);
  }
  .lamp.bad{
    background: var(--danger);
    border-color: color-mix(in srgb, var(--danger) 70%, #000 30%);
    box-shadow: 0 0 0 6px color-mix(in srgb, var(--danger) 22%, transparent 78%), 0 0 18px color-mix(in srgb, var(--danger) 55%, transparent 45%);
  }
  .gName{ font-weight:900; }
  .gThresh{ font-variant-numeric: tabular-nums; color: var(--muted); font-weight:850; }
  .gradeHint{ margin-top:8px; color: var(--muted); font-size:12px; line-height:1.35; }

/* --- Help modal --- */
.modal-backdrop{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  padding: 18px;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(6px);
  z-index: 9999;
}
.modal-backdrop.open{ display:flex; }

.modal{
  width: min(760px, 96vw);
  max-height: min(78vh, 760px);
  overflow:hidden;
  border-radius: 20px;
  border: 1px solid var(--border);
  background: color-mix(in srgb, var(--bg) 82%, #000 18%);
  box-shadow: 0 28px 80px rgba(0,0,0,0.55);
}
@media (prefers-color-scheme: light){
  .modal{ background: color-mix(in srgb, var(--bg) 92%, #fff 8%); }
}

.modal-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding: 14px 14px 12px 16px;
  border-bottom: 1px solid var(--border);
  background: rgba(255,255,255,0.03);
}
.modal-title{
  font-weight: 950;
  letter-spacing: 0.2px;
  font-size: 16px;
}
.modal-close{
  padding: 6px 10px;
  border-radius: 12px;
  box-shadow:none;
}

.modal-body{
  padding: 14px 16px 16px 16px;
  overflow:auto;
}
.modal-section{ margin-bottom: 14px; }
.modal-h{
  font-weight: 900;
  font-size: 12px;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: var(--muted);
  margin: 0 0 8px 0;
}
.modal-list{
  margin: 0;
  padding-left: 18px;
  line-height: 1.45;
  color: var(--text);
  font-size: 13px;
}
.modal-sublist{
  margin: 6px 0 0 0;
  padding-left: 18px;
  color: var(--muted);
}
.modal-note{
  margin-top: 8px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.03);
  color: var(--muted);
  font-size: 12px;
}


    .snapToggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,0.12);
      border-radius:10px;
      user-select:none;
      cursor:pointer;
      font-size:13px;
      color: rgba(255,255,255,0.9);
      background: rgba(255,255,255,0.04);
    }
  .edgeAgg{
    display:flex;
    align-items:center;
    gap:8px;
    padding:6px 10px;
    border:1px solid var(--border);
    border-radius:10px;
    background:rgba(255,255,255,0.04);
    font-size:12px;
    user-select:none;
  }
  .edgeAgg input[type="range"]{
    width:140px;
  }
  .edgeAgg .mono{
    font-variant-numeric: tabular-nums;
    min-width:54px;
    text-align:right;
  }

    .snapToggle input{ accent-color: var(--accent); }
    .snapToggle span{ white-space:nowrap; }

</style>
</head>
<body>
<div class="app">
  <div class="topbar">
    <div class="brand"><span class="dot"></span> Card Centering Tool </div>
    <div class="top-actions">

      <div class="row" id="sideTabs" style="gap:6px;">
        <button class="btn ghost" id="tabFront" data-side="front">Front</button>
        <button class="btn ghost" id="tabBack" data-side="back">Back</button>
      </div>

      <span class="pill" id="zoomPill">100%</span>
      <button class="btn" id="helpBtn" title="User guide">Help</button>
      <button class="btn" id="uploadBtn">Upload</button>
      <button class="btn" id="resetBtn" disabled>Reset</button>
      <button class="btn accent" id="exportBtn" disabled>Export PDF</button>
    </div>
  </div>

  <div class="content">
    <!-- Left panel -->
    <div class="panel">
      <div class="panel-inner col">
        <div>
          <div class="section-title">Workflow</div>
          <div class="card">
            <div class="hint">
              Zoom: pinch (touch) or mouse wheel.<br/>
              Pan: two-finger drag (touch) or <b>middle mouse</b> drag.<br/>
              Measure: click the borders as guided by the status.
            </div>
          </div>
        </div>

        <div>
          <div class="section-title">Geometry correction</div>
          <div class="card col" id="geomCard">
            <select id="geomMode" disabled>
              <option value="none">None</option>
              <option value="rotate">Rotate only</option>
              <option value="persp">Perspective (Pokémon 63×88)</option>
            </select>
            <div class="hint" id="geomHint">Load an image to begin.</div>
            <div class="row">              <button class="btn" id="geomApply" disabled>Apply</button>
              <button class="btn ghost" id="geomCancel" disabled>Cancel</button>
            </div>
          </div>
        </div>

        <div>
          <div class="section-title">Measure centring</div>
          <div class="card col" id="measureCard">
            <div class="row">
              <button class="btn primary" id="measureLR" disabled>Left / Right</button>
              <button class="btn primary" id="measureTB" disabled>Top / Bottom</button>
              <label class="snapToggle" title="When measuring, clicks will snap to the nearest strong border edge">
                <input type="checkbox" id="snapToBorderToggle">
                <span>Snap to border</span>
              </label>

              <label class="edgeAgg" title="Adjust how aggressively the tool detects edges (inner borders often need higher values)">
                <span>Edge detect</span>
                <input type="range" id="edgeAggSlider" min="50" max="250" value="120" step="5">
                <span class="mono" id="edgeAggVal">1.20×</span>
              </label>

<button class="btn danger" id="clearMarks" disabled>Clear selected</button>
              <button class="btn" id="clearMarksAll" disabled>Clear all</button>
            </div>
            <div class="hint">
              LR: L1 outer, L2 inner, R1 inner, R2 outer.<br/>
              TB: T1 outer, T2 inner, B1 inner, B2 outer.
            </div>
          </div>
        </div>

        <div>
          <div class="section-title">Status</div>
          <div class="card status" id="status">Load an image.</div>
        </div>
      </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-wrap" id="wrap">
      <canvas id="view"></canvas>
      <div class="toast" id="toast"></div>
    </div>

    <!-- Right panel -->
    <div class="panel">
      <div class="panel-inner col">
        <div class="section-title">Results</div>
        <div class="metric">
          <div class="label">Left / Right</div><div class="val" id="lrPct">–</div>
          <div class="sub" id="lrInfo">Not measured.</div>
        </div>
        <div class="metric">
          <div class="label">Top / Bottom</div><div class="val" id="tbPct">–</div>
          <div class="sub" id="tbInfo">Not measured.</div>
        </div>

        <div class="metric" id="gradeMetric">
          <div class="label">10 threshold (centering only)</div><div class="val"> </div>
          <div class="sub">
            <div class="gradeGrid">
              <div class="gradeRow">
                <span class="lamp" id="psaLamp" title="Pass/fail based on measured LR + TB (front uses 55/45, back uses 75/25)"></span>
                <span class="gName">PSA 10</span>
                <span class="gThresh">Front 55/45 · Back 75/25</span>
              </div>
              <div class="gradeRow">
                <span class="lamp" id="cgcLamp" title="Pass/fail based on measured LR + TB (front uses 55/45, back uses 75/25)"></span>
                <span class="gName">CGC 10</span>
                <span class="gThresh">Front 55/45 · Back 75/25</span>
              </div>
              <div class="gradeRow">
                <span class="lamp" id="aceLamp" title="Pass/fail based on measured LR + TB"></span>
                <span class="gName">ACE 10</span>
                <span class="gThresh">60/40</span>
              </div>
              <div class="gradeRow">
                <span class="lamp" id="bgsPristineLamp" title="Pass/fail based on measured LR + TB (front uses 50/50, back uses 60/40)"></span>
                <span class="gName">BGS Pristine 10</span>
                <span class="gThresh">Front 50/50 · Back 60/40</span>
              </div>
              <div class="gradeRow">
                <span class="lamp" id="cgcPristineLamp" title="Pass/fail based on measured LR + TB (CGC Pristine 10 shown as a safe guide)"></span>
                <span class="gName">CGC Pristine 10</span>
                <span class="gThresh">50/50 all around (≈)</span>
              </div>
            </div>
            <div class="gradeHint" id="gradeHint">Measure Left / Right and Top / Bottom to see pass or fail.</div>
          </div>
        </div>

        <div class="metric">
          <div class="label">Notes</div><div class="val"> </div>
          <div class="sub" id="notes">
            Pokémon aspect ratio: 63×88 mm (H/W ≈ 1.3968)<br/>
            Export PDF includes: annotated image, pixel counts, and centring %.<br/>
            Tip: phone photos look best at 2× zoom from a bit further back.<br/>
            <span style="color: var(--muted);">Disclaimer: This aims to estimate centring as accurately as possible, but results depend on image quality and it can’t account for lens distortion, perspective warp, or bent or warped cards.</span>
          </div>
        </div>

        <div class="divider"></div>
        <div class="hint">
          Keyboard: <span class="k">U</span> undo, <span class="k">R</span> clear current axis
        </div>
      </div>
    </div>

<!-- User guide modal -->
<div class="modal-backdrop" id="helpModal" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modal-header">
      <div class="modal-title" id="helpTitle">User guide</div>
      <button class="btn ghost modal-close" id="helpClose" aria-label="Close">✕</button>
    </div>

    <div class="modal-body">
      <div class="modal-section">
        <div class="modal-h">1) Load images</div>
        <ul class="modal-list">
          <li>Click <b>Upload</b> to load an image for the selected side (Front or Back).</li>
          <li>Use the <b>Front</b> and <b>Back</b> tabs to switch sides. Each side keeps its own zoom, pan, and measurements.</li>
        </ul>
      </div>

      <div class="modal-section">
        <div class="modal-h">2) Move and zoom</div>
        <ul class="modal-list">
          <li><b>Mouse wheel</b> zooms in and out.</li>
          <li><b>Trackpad two finger scroll</b> pans around.</li>
          <li><b>Pinch</b> on touch devices zooms. Two finger drag pans.</li>
          <li><b>Middle mouse drag</b> pans on desktop.</li>
        </ul>
      </div>

      <div class="modal-section">
        <div class="modal-h">3) Geometry correction (optional)</div>
        <ul class="modal-list">
          <li>Select a mode under <b>Geometry correction</b> to start immediately.</li>
          <li><b>Rotate only</b>: click 2 points along a border, then press <b>Apply</b>.</li>
          <li><b>Perspective</b>: draw 4 short lines in order <b>Top, Right, Bottom, Left</b> (8 clicks total), then <b>Apply</b>.</li>
        </ul>
      </div>

      <div class="modal-section">
        <div class="modal-h">4) Measure centring</div>
        <ul class="modal-list">
          <li>Choose <b>Left / Right</b> or <b>Top / Bottom</b>.</li>
          <li>Follow the order shown in <b>Status</b> exactly:
            <ul class="modal-sublist">
              <li>LR: L1 outer, L2 inner, R1 inner, R2 outer</li>
              <li>TB: T1 outer, T2 inner, B1 inner, B2 outer</li>
            </ul>
          </li>
          <li>Tips: zoom in so you can place clicks precisely on the border edges.</li>
        </ul>
      </div>

      <div class="modal-section">
        <div class="modal-h">5) Shortcuts and export</div>
        <ul class="modal-list">
          <li><b>U</b> undo last click for the active axis.</li>
          <li><b>R</b> clear the active axis.</li>
          <li>When Front and Back both have LR and TB measured, <b>Export PDF</b> enables.</li>
        </ul>
      </div>

      <div class="modal-note">
        Click outside this box or press <b>Esc</b> to close.
      </div>
    </div>
  </div>
</div>
  </div>
</div>

<script>
(() => {

  // --- Hoisted geometry DOM refs (ordering fix) ---
// Pokémon TCG standard size: 63 mm × 88 mm (2.5" × 3.5")
  const POKEMON_CARD_W = 63;
  const POKEMON_CARD_H = 88;
  const POKEMON_AR = POKEMON_CARD_H / POKEMON_CARD_W; // ~1.396825

  const wrap = document.getElementById("wrap");
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  const uploadBtn = document.getElementById("uploadBtn");
  const geomModeSel = document.getElementById("geomMode");
  const geomHint = document.getElementById("geomHint");
  const geomCard = document.getElementById("geomCard");
  const measureCard = document.getElementById("measureCard");
  const geomApply = document.getElementById("geomApply");
  const geomCancel = document.getElementById("geomCancel");

  const resetBtn = document.getElementById("resetBtn");
  const exportBtn = document.getElementById("exportBtn");
  const zoomPill = document.getElementById("zoomPill");
const measureLR = document.getElementById("measureLR");
  const measureTB = document.getElementById("measureTB");
  const snapToBorderToggle = document.getElementById("snapToBorderToggle");
  const snapToBorderWrap = document.querySelector("label.snapToggle");
  const edgeAggWrap = document.querySelector("label.edgeAgg");
  let snapToBorderEnabled = false;
  if (snapToBorderToggle) snapToBorderToggle.addEventListener("change", ()=>{ snapToBorderEnabled = !!snapToBorderToggle.checked; _invalidateSnapCaches(); draw(); });

  // Edge detection aggressiveness (higher helps inner borders)
  const edgeAggSlider = document.getElementById("edgeAggSlider");
  const edgeAggVal = document.getElementById("edgeAggVal");
  let EDGE_AGGRESSIVENESS = 1.20; // default matches slider value 120%

  function _edgeAgg(){
    return Math.max(0.5, Math.min(2.5, EDGE_AGGRESSIVENESS));
  }
  function _snapMinStrength(){
    // Higher aggressiveness both boosts measured strength and relaxes the cutoff a bit.
    return BASE_SNAP_MIN_STRENGTH / _edgeAgg();
  }

  if (edgeAggSlider){
    const apply = ()=>{
      const v = Number(edgeAggSlider.value || 120);
      EDGE_AGGRESSIVENESS = v / 100;
      if (edgeAggVal) edgeAggVal.textContent = `${EDGE_AGGRESSIVENESS.toFixed(2)}×`;
      draw();
    };
    edgeAggSlider.addEventListener("input", apply);
    apply();
  }
const clearMarks = document.getElementById("clearMarks");
  const clearMarksAll = document.getElementById("clearMarksAll");
  const statusEl = document.getElementById("status");

  const lrPct = document.getElementById("lrPct");
  const tbPct = document.getElementById("tbPct");
  const lrInfo = document.getElementById("lrInfo");
  const tbInfo = document.getElementById("tbInfo");

  const toast = document.getElementById("toast");


// ---------- Help modal ----------
const helpBtn = document.getElementById("helpBtn");
const helpModal = document.getElementById("helpModal");
const helpClose = document.getElementById("helpClose");

function openHelp(){
  if (!helpModal) return;
  helpModal.classList.add("open");
  helpModal.setAttribute("aria-hidden","false");
  // Prevent background interactions from feeling weird
  setToast("Tip: use middle mouse to pan, wheel to zoom.", 2200);
  // Focus the close button for keyboard users
  if (helpClose) helpClose.focus({preventScroll:true});
}
function closeHelp(){
  if (!helpModal) return;
  helpModal.classList.remove("open");
  helpModal.setAttribute("aria-hidden","true");
  if (helpBtn) helpBtn.focus({preventScroll:true});
}

if (helpBtn) helpBtn.addEventListener("click", openHelp);
if (helpClose) helpClose.addEventListener("click", closeHelp);

// Click outside the modal to close
if (helpModal) helpModal.addEventListener("mousedown", (e)=>{
  if (e.target === helpModal) closeHelp();
});

// Escape to close
window.addEventListener("keydown", (e)=>{
  if (e.key === "Escape" && helpModal && helpModal.classList.contains("open")){
    e.preventDefault();
    closeHelp();
  }
});


  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = "image/*";
  fileInput.style.position = "fixed";
  fileInput.style.left = "-9999px";
  fileInput.style.top = "-9999px";
  fileInput.style.opacity = "0";
  document.body.appendChild(fileInput);


  // Offscreen canvas holds the current transformed image pixels
  let baseCanvas = null;     // original loaded image
  let currentCanvas = null;  // transformed
  let imgW = 0, imgH = 0;

  // View transform (screen = pan + zoom * image)
  let zoom = 1.0;
  let panX = 0;
  let panY = 0;

  // Modes
  let activeAxis = "lr";
  // ===== Active side (Front/Back) and per-side image/view state =====
  let activeSide = "front";

// ===== STEP 1: Front / Back tabs (UI only, no behaviour change) =====

  // ===== STEP 2: Per-side image/view state (Front / Back) =====
  const sides = {
    front: {
      baseCanvas: null,
      currentCanvas: null,
      imgW: 0, imgH: 0,
      zoom: 1, panX: 0, panY: 0,
      perspRect: null
    },
    back: {
      baseCanvas: null,
      currentCanvas: null,
      imgW: 0, imgH: 0,
      zoom: 1, panX: 0, panY: 0,
      perspRect: null
    }
  };

  function saveActiveSide(){
    const s = sides[activeSide];
    s.baseCanvas = baseCanvas;
    s.currentCanvas = currentCanvas;
    s.imgW = imgW; s.imgH = imgH;
    s.zoom = zoom; s.panX = panX; s.panY = panY;
  }

  function loadActiveSide(){
    const s = sides[activeSide];
    baseCanvas = s.baseCanvas;
    currentCanvas = s.currentCanvas;
    imgW = s.imgW; imgH = s.imgH;
    zoom = s.zoom || 1;
    panX = s.panX || 0;
    panY = s.panY || 0;
    resize();
    updateResults();
    syncUI();
    draw();
  }
  const tabFront = document.getElementById("tabFront");
  const tabBack  = document.getElementById("tabBack");

  function syncSideTabs(){
    tabFront.style.borderColor = activeSide === "front" ? "rgba(49,199,255,0.8)" : "";
    tabBack.style.borderColor  = activeSide === "back"  ? "rgba(49,199,255,0.8)" : "";
  }

  tabFront.addEventListener("click", ()=>{
    saveActiveSide();
    activeSide = "front";
    loadActiveSide();
    syncSideTabs();
  updateResults();
    setToast("Front side selected");
  });

  tabBack.addEventListener("click", ()=>{
    saveActiveSide();
    activeSide = "back";
    loadActiveSide();
    syncSideTabs();
  updateResults();
    setToast("Back side selected");
  });


  
  // ===== STEP 3: Per-side measurement state =====
  const measureSides = {
    front: {
      lr: { pts: [], result: null },
      tb: { pts: [], result: null }
    },
    back: {
      lr: { pts: [], result: null },
      tb: { pts: [], result: null }
    }
  };

  function MS(){
    return measureSides[activeSide];
  }

  // ===== Perspective rect per side (used for measurement) =====
  function setPerspRect(sideKey, rect){
    if (!sides[sideKey]) return;
    sides[sideKey].perspRect = rect;
  }
  function getPerspRect(){
    return (sides[activeSide] && sides[activeSide].perspRect) ? sides[activeSide].perspRect : null;
  }


  // Initialise side tabs and state once measurement state exists
  syncSideTabs();
  loadActiveSide();

  

  // Geometry correction capture
  let geomMode = "none"; // none | rotate | persp
  let geomCapturing = false;

  // Rotate: 1 short line (2 clicks)
  let rotPts = []; // [{x,y},{x,y}]

  // Perspective: 4 lines (top,right,bottom,left), 2 clicks each
  let perspLines = []; // [{a,b}] length 0..4
  let perspTemp = null; // first click of current line

  // Pointer handling for pinch/pan
  const pointers = new Map(); // id -> {x,y,type,buttons}
  let pinchStartDist = 0;
  let pinchStartZoom = 1;
  let pinchStartPanX = 0;
  let pinchStartPanY = 0;
  let pinchStartCenter = {x:0,y:0};
  let isMiddlePanning = false;
  let hoverImgPt = null;
  let pointerImgPt = null;
  let hoverPixel = null; // {x:int,y:int} pixel cell that would be selected if clicked
  let middlePanStart = {x:0,y:0, panX:0, panY:0};

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function fmt1(n){ return Number(n).toFixed(1); }

  function setToast(msg, ms=4500){
    toast.textContent = msg;
    toast.style.display = "block";
    clearTimeout(setToast._t);
    setToast._t = setTimeout(()=> toast.style.display="none", ms);
  }

  // --- Edge guidance glow helpers ---
  function setWrapEdgeGlow(edge){
    if (!wrap) return;
    const edgeClasses = ["edge-left","edge-right","edge-top","edge-bottom","edge-all"];
    for (const c of edgeClasses) wrap.classList.remove(c);
    if (!edge) return;
    const cls = "edge-" + edge;
    if (edgeClasses.includes(cls)) wrap.classList.add(cls);
  }

  function getNextEdgeHint(){
    if (!currentCanvas) return null;

    // Geometry capture has priority
    if (geomCapturing){
      if (geomMode === "persp"){
        const order = ["top","right","bottom","left"];
        const i = perspLines.length;
        if (i >= 4 && !perspTemp) return null;
        return order[Math.min(i, 3)] || null;
      }
      // Rotate: user can pick any straight border, so just glow all edges
      if (geomMode === "rotate"){
        return (rotPts.length < 2) ? "all" : null;
      }
      return null;
    }

    // Measurement guidance
    const pts = MS()[activeAxis].pts;
    if (!pts || pts.length >= 4) return null;

    if (activeAxis === "lr"){
      // L1, L2 => left; R1, R2 => right
      return (pts.length < 2) ? "left" : "right";
    } else {
      // T1, T2 => top; B1, B2 => bottom
      return (pts.length < 2) ? "top" : "bottom";
    }
  }


  window.addEventListener("error", (ev)=>{
    try{
      const where = (ev.filename ? (" @ " + ev.filename.split("/").pop()) : "") + (ev.lineno ? (":" + ev.lineno) : "");
      setToast("JS error: " + (ev.message || "unknown") + where, 12000);
    }catch(_){ }
  });

  function resize(){
    const r = wrap.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
    canvas.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    draw();
  }
  window.addEventListener("resize", resize);
  // Keep canvas perfectly in sync if layout changes (e.g., sidebar text reflow)
  const ro = new ResizeObserver(() => resize());
  ro.observe(wrap);

  // iOS Safari: prevent page pinch-zoom/gesture zoom so our pinch-to-zoom works inside the canvas.
  // Must be registered once, not inside draw loops.
  document.addEventListener("gesturestart", (e)=> e.preventDefault(), { passive:false });
  document.addEventListener("gesturechange", (e)=> e.preventDefault(), { passive:false });
  document.addEventListener("gestureend", (e)=> e.preventDefault(), { passive:false });


  function imgToScreen(p){
    return { x: panX + p.x * zoom, y: panY + p.y * zoom };
  }
  function screenToImg(sx, sy){
    const x = (sx - panX) / zoom;
    const y = (sy - panY) / zoom;
    return { x, y, inBounds: (x>=0 && x<=imgW && y>=0 && y<=imgH) };
  }


  function projectAlongAxis(anchor, target, axis){
    // axis 'lr' => horizontal line (lock Y); 'tb' => vertical line (lock X)
    if (axis === "lr") return { x: target.x, y: anchor.y };
    return { x: anchor.x, y: target.y };
  }


  function drawFullImageGuide(anchor, axis, colour){
    // Draw a dashed guide across the FULL image extent, in image space.
    // LR => y fixed, x from 0..imgW; TB => x fixed, y from 0..imgH.
    const dash = [14, 10];
    if (axis === "lr"){
      const A = imgToScreen({x:0, y:anchor.y});
      const B = imgToScreen({x:imgW, y:anchor.y});
      drawLine(A,B, colour, 2.2, dash);
    } else {
      const A = imgToScreen({x:anchor.x, y:0});
      const B = imgToScreen({x:anchor.x, y:imgH});
      drawLine(A,B, colour, 2.2, dash);
    }
  }

  function projectToAxis(anchor0, target, axis){
    // Locks to the axis defined by the FIRST click for that measurement set.
    if (axis === "lr") return { x: target.x, y: anchor0.y };
    return { x: anchor0.x, y: target.y };
  }
  // --- Shared edge-strength helpers (used by Snap-to-border) ---
  // These are lightweight gradient-based edge detectors over the CURRENT canvas pixels.
  // They are global-scope so they can be used by mousemove/click snapping without any measurement pipeline.
  let _snapImgCache = { canvas: null, w: 0, h: 0, img: null, t: 0 };

  function _getSnapImageData(){
    // Cache for performance: refresh occasionally, and always when the backing canvas or dimensions change.
    if (!currentCanvas || !imgW || !imgH) return null;
    const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    const stale = (now - (_snapImgCache.t || 0)) > 250; // ms
    if (_snapImgCache.canvas !== currentCanvas || _snapImgCache.w !== imgW || _snapImgCache.h !== imgH || !_snapImgCache.img || stale){
      const ctx = currentCanvas.getContext('2d', { willReadFrequently: true });
      try {
        _snapImgCache = { canvas: currentCanvas, w: imgW, h: imgH, img: ctx.getImageData(0, 0, imgW, imgH), t: now };
      } catch (e){
        // Some browsers can throw if the canvas is tainted. In that case, snapping is disabled gracefully.
        _snapImgCache = { canvas: currentCanvas, w: imgW, h: imgH, img: null, t: now };
        return null;
      }
    }
    return _snapImgCache.img;
  }

  function _lumAt(img, x, y){
    // Fast-ish luminance estimate from RGBA
    const w = img.width, h = img.height;
    x = Math.max(0, Math.min(w - 1, x|0));
    y = Math.max(0, Math.min(h - 1, y|0));
    const i = (y * w + x) * 4;
    const d = img.data;
    return 0.2126 * d[i] + 0.7152 * d[i+1] + 0.0722 * d[i+2];
  }

  function _rgbAt(img, x, y){
    const w = img.width, h = img.height;
    x = Math.max(0, Math.min(w - 1, x|0));
    y = Math.max(0, Math.min(h - 1, y|0));
    const i = (y * w + x) * 4;
    const d = img.data;
    return [d[i], d[i+1], d[i+2]];
  }

  // --- Snap-to-border edge buffers (greyscale + directional gradients) ---
// For colourful/holo cards, snapping on a greyscale edge map is far more stable than raw RGB contrast.
let _snapEdgeCache = { canvas: null, w: 0, h: 0, gx: null, gy: null, grayCanvas: null, t: 0 };

function _invalidateSnapCaches(){
  _snapImgCache = { canvas: null, w: 0, h: 0, img: null, t: 0 };
  _snapEdgeCache = { canvas: null, w: 0, h: 0, gx: null, gy: null, grayCanvas: null, t: 0 };
}

function _getSnapDisplayCanvas(){
  // When snap-to-border is enabled, show a greyscale view (helps the user place points and matches the snap signal).
  if (!snapToBorderEnabled) return currentCanvas;
  const e = _getSnapEdgeBuffers();
  return (e && e.grayCanvas) ? e.grayCanvas : currentCanvas;
}

function _getSnapEdgeBuffers(){
  if (!currentCanvas || !imgW || !imgH) return null;

  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  // Cache is rebuilt only when the underlying image changes (invalidate caches on load/transform).
  if (_snapEdgeCache.canvas === currentCanvas && _snapEdgeCache.w === imgW && _snapEdgeCache.h === imgH &&
      _snapEdgeCache.gx && _snapEdgeCache.gy && _snapEdgeCache.grayCanvas){
    return _snapEdgeCache;
  }

  const src = _getSnapImageData();
  if (!src) return null;

  const w = src.width, h = src.height;
  const d = src.data;

  // Build greyscale array
  const gray = new Uint8ClampedArray(w * h);
  for (let i = 0, p = 0; i < d.length; i += 4, p++){
    // BT.709-ish, but any sane greyscale works here
    gray[p] = (0.2126 * d[i] + 0.7152 * d[i+1] + 0.0722 * d[i+2]) | 0;
  }

  // Directional gradients:
  // gx responds strongly to vertical edges (left/right change)
  // gy responds strongly to horizontal edges (top/bottom change)
  const gx = new Uint8ClampedArray(w * h);
  const gy = new Uint8ClampedArray(w * h);

  // Simple Sobel-lite using 1D [-1,0,1] across each axis, plus a tiny smoothing via neighbour averaging.
  for (let y = 1; y < h - 1; y++){
    const row = y * w;
    for (let x = 1; x < w - 1; x++){
      const p = row + x;

      const l = gray[p - 1];
      const r = gray[p + 1];
      const u = gray[p - w];
      const dn = gray[p + w];

      // Neighbour smoothing (reduces artwork noise)
      const l2 = (gray[p - 2] + l) >> 1;
      const r2 = (gray[p + 2] + r) >> 1;
      const u2 = (gray[p - 2*w] + u) >> 1;
      const d2 = (gray[p + 2*w] + dn) >> 1;

      const dx = Math.abs(r2 - l2);
      const dy = Math.abs(d2 - u2);

      gx[p] = dx > 255 ? 255 : dx;
      gy[p] = dy > 255 ? 255 : dy;
    }
  }

  // Build greyscale display canvas
  const grayCanvas = document.createElement('canvas');
  grayCanvas.width = w; grayCanvas.height = h;
  const gctx = grayCanvas.getContext('2d', { willReadFrequently: false });
  const out = new Uint8ClampedArray(w * h * 4);
  for (let p = 0, i = 0; p < w*h; p++, i += 4){
    const g = gray[p];
    out[i] = out[i+1] = out[i+2] = g;
    out[i+3] = 255;
  }
  gctx.putImageData(new ImageData(out, w, h), 0, 0);

  _snapEdgeCache = { canvas: currentCanvas, w, h, gx, gy, grayCanvas, t: now };
  return _snapEdgeCache;
}

function _edgeAt(buf, x, y){
  const w = imgW, h = imgH;
  x = Math.max(0, Math.min(w - 1, x|0));
  y = Math.max(0, Math.min(h - 1, y|0));
  return buf[y * w + x] || 0;
}

// Strength functions used by the snapper.
// On the edge map these are already "strength", so we only scale by aggressiveness.
function edgeStrengthX(x, y){
  const e = _getSnapEdgeBuffers();
  if (!e || !e.gx) return 0;
  return _edgeAt(e.gx, x, y) * _edgeAgg() / 40; // scale to roughly match previous numeric ranges
}

function edgeStrengthY(x, y){
  const e = _getSnapEdgeBuffers();
  if (!e || !e.gy) return 0;
  return _edgeAt(e.gy, x, y) * _edgeAgg() / 40;
}

// --- Snap-to-border (manual measuring helper) ---
// This intentionally does NOT "measurement". It only nudges the user's click/hover to a nearby strong edge.
const SNAP_SEARCH_PX = 90;         // how far (in image pixels) to search from the cursor
const BASE_SNAP_MIN_STRENGTH = 2.8;      // lower = more eager snapping (helps colourful inner borders)
const SNAP_MIN_EDGE_STRENGTH = 4.0; // base minimum edge strength (scaled by slider)
const SNAP_MAX_JUMP_PX = 15;       // don't snap if it would jump further than this       // don't snap if it would jump further than this
const SNAP_BAND_SPAN_PX = 34;      // sample +/- this along the axis to tolerate curvature      // sample +/- this along the axis to tolerate curvature
const SNAP_BAND_STEP_PX = 5;       // step for band sampling       // step for band sampling
const SNAP_DIST_PENALTY = 0.75;
  // Jitter control for snapping (least-annoying combo)
  const SNAP_TIE_EPS = 0.25;            // if scores are within this, prefer the closer edge
  const SNAP_SMOOTH_ALPHA = 0.38;       // 0..1, higher = snappier, lower = smoother
  const SNAP_SMOOTH_SNAP_PX = 18;       // if the snap target jumps more than this, snap immediately (no easing)
  let _snapHoverSmoothed = null;        // smoothed hover point in image space (for always-follows-snap preview)
  let _snapHoverRaw = null;             // last raw snapped hover (pre-smoothing)
    // higher = prefers closer edges more strongly    // higher = prefers closer edges more strongly

function _collectEdgeCandidates1D(pos0, pos1, strengthAt){
  // Scan along a 1D axis and return candidate peaks using a local adaptive threshold.
  // Improvements for colourful cards:
  // - light smoothing to suppress artwork texture noise
  // - thresholding computed on smoothed values
  const samples = [];
  const vals = [];

  for (let p = pos0; p <= pos1; p++){
    const v = strengthAt(p);
    samples.push({p, v});
    vals.push(v);
  }

  // Smooth strengths a bit. Border edges are spatially consistent; texture spikes are not.
  const smoothVals = (function(){
    const out = new Array(vals.length);
    const win = 5;           // odd window size
    const half = (win-1)/2;
    for (let i = 0; i < vals.length; i++){
      let sum = 0, cnt = 0;
      for (let k = -half; k <= half; k++){
        const j = i + k;
        if (j >= 0 && j < vals.length){ sum += vals[j]; cnt++; }
      }
      out[i] = cnt ? (sum / cnt) : vals[i];
    }
    return out;
  })();

  // Robust baseline: median + MAD (less sensitive to texture spikes)
  function _median(arr){
    if (!arr.length) return 0;
    const a = arr.slice().sort((x,y)=>x-y);
    const mid = Math.floor(a.length/2);
    return (a.length % 2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
  }

  const med = _median(smoothVals);
  const absDev = smoothVals.map(v=>Math.abs(v - med));
  const mad = _median(absDev);
  const scale = (mad * 1.4826) + 1e-6; // ~stddev for normal noise

  // Slider-aware z-threshold. Higher aggressiveness => lower z needed.
  const zMin = clamp(2.0 / _edgeAgg(), 0.7, 3.0);

  // Hard cutoff (legacy) and adaptive cutoff (local). Use the easier one.
  const hardCut = _snapMinStrength();
  const adaptiveCut = med + (zMin * scale);
  const cut = Math.min(hardCut, adaptiveCut);

  const cand = [];
  let inCluster = false;
  let bestPos = null;
  let bestVal = -Infinity;      // raw (unsmoothed) strength
  let bestSmooth = -Infinity;   // smoothed strength

  for (let i = 0; i < samples.length; i++){
    const s = samples[i];
    const p = s.p;
    const v = s.v;
    const vs = smoothVals[i];

    if (vs >= cut){
      if (!inCluster){
        inCluster = true;
        bestPos = p;
        bestVal = v;
        bestSmooth = vs;
      } else {
        // Prefer stronger smoothed peak; tie break with raw strength.
        if (vs > bestSmooth || (Math.abs(vs - bestSmooth) < 1e-6 && v > bestVal)){
          bestSmooth = vs;
          bestVal = v;
          bestPos = p;
        }
      }
    } else {
      if (inCluster){
        const z = (bestSmooth - med) / scale;
        cand.push({ pos: bestPos, strength: bestVal, val: bestVal, z });
        inCluster = false;
        bestPos = null;
        bestVal = -Infinity;
        bestSmooth = -Infinity;
      }
    }
  }
  if (inCluster){
    const z = (bestSmooth - med) / scale;
    cand.push({ pos: bestPos, strength: bestVal, val: bestVal, z });
  }
  return cand;
}


function _pickNearestCandidate(candidates, cursorPos){
  if (!candidates || candidates.length === 0) return null;
  let best = null;
  let bestDist = Infinity;
  for (const c of candidates){
    const d = Math.abs(c.pos - cursorPos);
    if (d < bestDist){
      bestDist = d;
      best = c;
    }
  }
  // refuse huge jumps
  if (best && bestDist <= SNAP_MAX_JUMP_PX) return best;
  return null;
}


function snapPointToBorder(pt, axis, anchor){
  // Snap the moving point to the nearest strong vertical/horizontal edge *using a small band*.
  // This makes snapping feel real, even when the line is slightly curved or the photo is skewed.
  // axis: "lr" => snap X (vertical edges), "tb" => snap Y (horizontal edges)
  if (!currentCanvas || !pt) return pt;

  const px = clamp(Math.round(pt.x), 0, imgW-1);
  const py = clamp(Math.round(pt.y), 0, imgH-1);

  // Band sampling settings (tuned for phone pics and mild curvature)
  const bandSpan = (anchor ? 14 : SNAP_BAND_SPAN_PX);     // sample +/- this far along the axis
  const bandStep = (anchor ? 2 : SNAP_BAND_STEP_PX);     // step along the axis

  const searchPx = SNAP_SEARCH_PX;        // how far to look for an edge (perpendicular)

  // After the first click, restrict snapping to the measurement axis band and make subtle inner borders easier to catch.

  function edgeStrengthXBand(x, y){
    const yy = clamp(Math.round(y), 0, imgH-1);
    const y0 = clamp(yy - 1, 0, imgH-1);
    const y1 = clamp(yy + 1, 0, imgH-1);
    return (edgeStrengthX(x, y0) + edgeStrengthX(x, yy) + edgeStrengthX(x, y1)) / 3;
  }
  function edgeStrengthYBand(x, y){
    const xx = clamp(Math.round(x), 0, imgW-1);
    const x0 = clamp(xx - 1, 0, imgW-1);
    const x1 = clamp(xx + 1, 0, imgW-1);
    return (edgeStrengthY(xx, y) + edgeStrengthY(x0, y) + edgeStrengthY(x1, y)) / 3;
  }

  function weightedMedian(samples){
    if (!samples.length) return null;
    const arr = samples.slice().sort((a,b)=>a.pos-b.pos);
    const total = arr.reduce((s,o)=>s+o.w,0);
    let acc = 0;
    for (const o of arr){
      acc += o.w;
      if (acc >= total*0.5) return o.pos;
    }
    return arr[arr.length-1].pos;
  }

  // Helper: pick best candidate near "target" from a 1D scan
  function bestCandidateNear(cands, target){
    if (!cands || !cands.length) return null;
    let best = null;
    let bestScore = -Infinity;
    let bestDist = Infinity;

    for (const c of cands){
      const d = Math.abs(c.pos - target);
      // Prefer closer, but allow a slightly farther candidate if it's much stronger.
      const score = ((c.strength ?? c.val) * 1.0) - (d * SNAP_DIST_PENALTY);

      // Stable tie-breaker: if scores are very close, choose the nearer candidate.
      if (score > bestScore + SNAP_TIE_EPS){
        bestScore = score;
        bestDist = d;
        best = c;
      } else if (Math.abs(score - bestScore) <= SNAP_TIE_EPS){
        if (d < bestDist){
          bestScore = score;
          bestDist = d;
          best = c;
        }
      }
    }

    // Enforce "must actually move a bit" to avoid micro-jitter
    if (best && Math.abs(best.pos - target) < 1) return null;
    return best;
  }

  if (axis === "lr"){
    const yCenter = clamp(Math.round(anchor?.y ?? py), 0, imgH-1);
    const x0 = clamp(px - searchPx, 0, imgW-1);
    const x1 = clamp(px + searchPx, 0, imgW-1);

    const samples = [];
    for (let dy = -bandSpan; dy <= bandSpan; dy += bandStep){
      const yy = clamp(yCenter + dy, 0, imgH-1);
      const cands = _collectEdgeCandidates1D(x0, x1, (xx)=> edgeStrengthXBand(xx, yy));
      const picked = bestCandidateNear(cands, px);
      if (picked){
        samples.push({ pos: picked.pos, w: picked.strength });
      }
    }

    const xSnap = weightedMedian(samples);
    if (xSnap == null) return pt;

    const jump = Math.abs(xSnap - px);
    if (jump > SNAP_MAX_JUMP_PX) return pt;

    return { x: xSnap, y: yCenter };
  } else {
    const xCenter = clamp(Math.round(anchor?.x ?? px), 0, imgW-1);
    const y0 = clamp(py - searchPx, 0, imgH-1);
    const y1 = clamp(py + searchPx, 0, imgH-1);

    const samples = [];
    for (let dx = -bandSpan; dx <= bandSpan; dx += bandStep){
      const xx = clamp(xCenter + dx, 0, imgW-1);
      const cands = _collectEdgeCandidates1D(y0, y1, (yy)=> edgeStrengthYBand(xx, yy));
      const picked = bestCandidateNear(cands, py);
      if (picked){
        samples.push({ pos: picked.pos, w: picked.strength });
      }
    }

    const ySnap = weightedMedian(samples);
    if (ySnap == null) return pt;

    const jump = Math.abs(ySnap - py);
    if (jump > SNAP_MAX_JUMP_PX) return pt;

    return { x: xCenter, y: ySnap };
  }
}

  function centreImage(){
    const r = wrap.getBoundingClientRect();
    if (!imgW || !imgH) return;
    const maxW = r.width, maxH = r.height;
    const fit = Math.min(maxW / imgW, maxH / imgH);
    zoom = clamp(fit, 0.10, 8.0);
    panX = (maxW - imgW*zoom)/2;
    panY = (maxH - imgH*zoom)/2;
    updateZoomPill();
  }
  function updateZoomPill(){
    zoomPill.textContent = `${Math.round(zoom*100)}%`;
  }

  function syncUI(){
    const loaded = !!currentCanvas;

    // Upload button guidance: glow when the current side has no image loaded
    if (uploadBtn) uploadBtn.classList.toggle("needs-upload", !loaded);

    resetBtn.disabled = !loaded;
    exportBtn.disabled = !(
      (sides.front.currentCanvas && measureSides.front.lr.result && measureSides.front.tb.result) ||
      (sides.back.currentCanvas && measureSides.back.lr.result && measureSides.back.tb.result)
    );

    geomModeSel.disabled = !loaded;
    geomApply.disabled = !loaded || !geomCapturing || ((geomMode === "rotate") ? (rotPts.length !== 2) : (perspLines.length !== 4 || !!perspTemp));
    geomCancel.disabled = !loaded || !geomCapturing;

    // Measure section
    measureLR.disabled = !loaded || geomCapturing;
    measureTB.disabled = !loaded || geomCapturing;

    // Disable snap + edge slider until measuring is available (same rules as the measure buttons)
    if (snapToBorderToggle) snapToBorderToggle.disabled = !loaded || geomCapturing;
    if (edgeAggSlider) edgeAggSlider.disabled = !loaded || geomCapturing;

    // Make snap + slider LOOK disabled (match button disabled styling)
    if (snapToBorderWrap) snapToBorderWrap.classList.toggle("ctrlDisabled", !!(snapToBorderToggle && snapToBorderToggle.disabled));
    if (edgeAggWrap) edgeAggWrap.classList.toggle("ctrlDisabled", !!(edgeAggSlider && edgeAggSlider.disabled));

    clearMarks.disabled = !loaded;
    clearMarksAll.disabled = !loaded;

    // Active section highlighting
    if (geomCard) geomCard.classList.toggle("active-geom", !!loaded && geomCapturing);
    if (measureCard) measureCard.classList.toggle("active-measure", !!loaded && !geomCapturing && (MS().lr.pts.length < 4 || MS().tb.pts.length < 4));

    // Highlight current axis
    measureLR.style.borderColor = (activeAxis === "lr") ? "rgba(49,199,255,0.7)" : "";
    measureTB.style.borderColor = (activeAxis === "tb") ? "rgba(49,199,255,0.7)" : "";

    if (!loaded){
      geomHint.textContent = "Load an image to begin.";
    } else {
      if (geomMode === "none"){
        geomHint.textContent = "No correction. Measure directly.";
      } else if (geomMode === "rotate"){
        geomHint.innerHTML = "Rotate only: draw a short line along a border to straighten the image. <br/>2 clicks total.";
      } else {
        geomHint.innerHTML = "Perspective (Pokémon 63×88): draw 4 short lines on the borders in order Top, Right, Bottom, Left. <br/>8 clicks total.";
      }
    }

    updateStatus();
  }

  function updateStatus(){
    if (!MS) return;
    if (!currentCanvas){
      statusEl.textContent = "Load an image.";
      setWrapEdgeGlow(null);
      return;
    }
    if (geomCapturing){
      if (geomMode === "rotate"){
        const next = (rotPts.length===0) ? "Rot1" : (rotPts.length===1) ? "Rot2" : "Apply";
        statusEl.textContent = `Geometry: Rotate\nNext: ${next}\n\nTip: draw along a border.`;
      } else if (geomMode === "persp"){
        const names = ["Top","Right","Bottom","Left"];
        const i = perspLines.length;
        if (i>=4 && !perspTemp){
          statusEl.textContent = "Geometry: Perspective\nAll 4 lines captured.\nPress Apply.";
        } else {
          const step = perspTemp ? "2nd click" : "1st click";
          statusEl.textContent = `Geometry: Perspective\nNext: ${names[i]} line (${step})\nProgress: ${perspLines.length}/4 lines`;
        }
      }
      setWrapEdgeGlow(getNextEdgeHint());
      return;
    }

    const lrDone = MS().lr.pts.length===4;
    const tbDone = MS().tb.pts.length===4;
    const bothDone = lrDone && tbDone;

    const nextLabel = (() => {
      const pts = MS()[activeAxis].pts;
      if (activeAxis==="lr"){
        const labels=["L1 (outer left)","L2 (inner left)","R1 (inner right)","R2 (outer right)"];
        return labels[pts.length] || "LR complete";
      } else {
        const labels=["T1 (outer top)","T2 (inner top)","B1 (inner bottom)","B2 (outer bottom)"];
        return labels[pts.length] || "TB complete";
      }
    })();

    statusEl.textContent =
`Measuring: ${activeAxis==="lr" ? "Left / Right" : "Top / Bottom"}
Next: ${nextLabel}
Progress: LR ${MS().lr.pts.length}/4, TB ${MS().tb.pts.length}/4
${bothDone ? "\nReady to export PDF." : ""}`;


    // Update the canvas edge glow hint
    setWrapEdgeGlow(getNextEdgeHint());
  }

  function drawLine(a,b, color, width=3, dash=null){
    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    if (dash) ctx.setLineDash(dash);
    ctx.shadowColor = color;
    ctx.shadowBlur = dash ? 4 : 10;
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
    ctx.restore();
  }
  function drawLabel(imgPt, text, color){
    const p = imgToScreen(imgPt);
    ctx.save();
    ctx.font = "900 12px ui-sans-serif, system-ui";
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillText(text, p.x+1, p.y+13);
    ctx.fillStyle = color;
    ctx.fillText(text, p.x, p.y+12);
    ctx.restore();
  }

  function draw(){
    try {
    const r = wrap.getBoundingClientRect();
    ctx.clearRect(0,0,r.width,r.height);

    // background grid
    ctx.save();
    ctx.globalAlpha = 0.18;
    const step = 28;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border').trim();
    ctx.lineWidth = 1;
    for (let x=0; x<r.width; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,r.height); ctx.stroke();
    }
    for (let y=0; y<r.height; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(r.width,y); ctx.stroke();
    }
    ctx.restore();

    if (!currentCanvas) return;

    // draw image
    ctx.save();
    ctx.translate(panX, panY);
    ctx.scale(zoom, zoom);
    ctx.imageSmoothingEnabled = false;
    ctx.imageSmoothingQuality = "low";
    ctx.drawImage(_getSnapDisplayCanvas() || currentCanvas, 0, 0);
    ctx.restore();

    // Pixel hover highlight (only really visible when zoomed in)
    // Show the *exact pixel cell* that would be selected if the user clicked right now.
    hoverPixel = null;
    if (pointerImgPt && currentCanvas){
      // Work out the candidate point that would be stored on click
      let cand = pointerImgPt;

if (!geomCapturing){
  const pts = MS()[activeAxis].pts;
  const anchor = (pts && pts.length >= 1) ? pts[0] : null;

  // First lock to axis (as before)
  if (anchor){
    cand = projectToAxis(anchor, pointerImgPt, activeAxis);
  }

  // Then optionally snap the hover point to a nearby strong border edge
  if (snapToBorderEnabled){
    const base = anchor ? cand : pointerImgPt;
    const snapAnchor = anchor || base;

    // Raw snapped point (no smoothing)
    const rawSnap = snapPointToBorder(base, activeAxis, snapAnchor);
    _snapHoverRaw = rawSnap;

    // Smooth the hover snap so it always follows, but doesn't jitter.
    if (!_snapHoverSmoothed){
      _snapHoverSmoothed = { x: rawSnap.x, y: rawSnap.y };
    } else {
      const dx = rawSnap.x - _snapHoverSmoothed.x;
      const dy = rawSnap.y - _snapHoverSmoothed.y;
      const dist = Math.hypot(dx, dy);

      if (dist > SNAP_SMOOTH_SNAP_PX){
        // Large change (likely switching edges): jump to target so it doesn't "lag behind".
        _snapHoverSmoothed.x = rawSnap.x;
        _snapHoverSmoothed.y = rawSnap.y;
      } else {
        // Gentle easing
        _snapHoverSmoothed.x += dx * SNAP_SMOOTH_ALPHA;
        _snapHoverSmoothed.y += dy * SNAP_SMOOTH_ALPHA;
      }
    }

    cand = { x: _snapHoverSmoothed.x, y: _snapHoverSmoothed.y };
  } else {
    _snapHoverRaw = null;
    _snapHoverSmoothed = null;
  }
} else {
  _snapHoverRaw = null;
  _snapHoverSmoothed = null;
}

      const px = Math.floor(cand.x);
      const py = Math.floor(cand.y);
      if (px >= 0 && py >= 0 && px < currentCanvas.width && py < currentCanvas.height){
        hoverPixel = { x:px, y:py };
        const sx = panX + px * zoom;
        const sy = panY + py * zoom;
        const sz = zoom;

        ctx.save();
        ctx.lineWidth = 1;
        ctx.setLineDash([]);
        // subtle fill
        ctx.fillStyle = "rgba(49,199,255,0.18)";
        ctx.fillRect(sx, sy, sz, sz);
        // crisp outline
        ctx.strokeStyle = "rgba(255,255,255,0.85)";
        ctx.strokeRect(sx + 0.5, sy + 0.5, sz - 1, sz - 1);
        ctx.restore();
      }
    }

    // overlays (in screen coords)
    const colors = {
      solid: "rgba(49,199,255,1)",
      solidTB: "rgba(255,165,0,1)",
      guide: "rgba(130,230,255,0.9)",
      guideTB: "rgba(255,165,0,0.9)",
      geom: "rgba(255,206,92,1)",
      geomGuide: "rgba(255,206,92,0.9)"
    };

    // Geometry overlays
    if (geomCapturing){
      if (geomMode === "rotate"){
        for (let i=0;i<rotPts.length;i++){
          drawLabel(rotPts[i], `Rot${i+1}`, colors.geom);
        }
        if (rotPts.length===1 && pointerImgPt){
          // dashed preview to pointer
          drawLine(imgToScreen(rotPts[0]), imgToScreen(pointerImgPt), colors.geomGuide, 3, [14,10]);
        }
        if (rotPts.length===2){
          drawLine(imgToScreen(rotPts[0]), imgToScreen(rotPts[1]), colors.geom, 4, null);
        }
      } else if (geomMode === "persp"){
        const names=["Top","Right","Bottom","Left"];
        for (let i=0;i<perspLines.length;i++){
          const L = perspLines[i];
          drawLine(imgToScreen(L.a), imgToScreen(L.b), colors.geom, 4, null);
          drawLabel(L.a, names[i]+"1", colors.geom);
          drawLabel(L.b, names[i]+"2", colors.geom);
        }
        if (perspTemp){
          drawLabel(perspTemp, names[perspLines.length]+"1", colors.geom);
          if (pointerImgPt){
            drawLine(imgToScreen(perspTemp), imgToScreen(pointerImgPt), colors.geomGuide, 3, [14,10]);
          }
        }
      }
    }

    // Measurement overlays
    const bothDone = MS().lr.pts.length===4 && MS().tb.pts.length===4;
    const showGuides = !bothDone; // hide dashed guides when both complete

    // Locked guide previews (v6.2-style, fixed)
    // - Guide is defined by the FIRST click on each axis, and persists until that axis is complete.
    // - All subsequent clicks are snapped to that axis (prevents offset).
    // - Rubber-band preview follows the dashed guide.
    if (!geomCapturing) {
      // LR axis
      if (showGuides && MS().lr.pts.length >= 1 && MS().lr.pts.length < 4) {
        drawFullImageGuide(MS().lr.pts[0], "lr", colors.guide);
      }
      // TB axis
      if (showGuides && MS().tb.pts.length >= 1 && MS().tb.pts.length < 4) {
        drawFullImageGuide(MS().tb.pts[0], "tb", colors.guideTB);
      }

      const pts = MS()[activeAxis].pts;
// Rubber-banding behaviour for border measurement:
      // - Show preview after click 1 (outer) until click 2 (inner) is placed
      // - Stop preview between clicks 2 -> 3
      // - Show preview again after click 3 (inner) until click 4 (outer) is placed
      const rubberBandAllowed = (pts.length === 1 || pts.length === 3);

      if (pointerImgPt && rubberBandAllowed) {
        const a0 = pts[0];
        const last = pts[pts.length - 1];
        let proj = projectToAxis(a0, pointerImgPt, activeAxis);
        if (snapToBorderEnabled){
          proj = snapPointToBorder(proj, activeAxis, a0);
        }
        // dashed preview aligned to guide + solid fill
        drawLine(imgToScreen(last), imgToScreen(proj), (activeAxis==="tb" ? (colors.guideTB||colors.guide) : colors.guide), 2.8, [14,10]);
        drawLine(imgToScreen(last), imgToScreen(proj), (activeAxis==="tb" ? (colors.solidTB||colors.solid) : colors.solid), 4, null);
      }
    }

for (const key of ["lr","tb"]){
      const pts = MS()[key].pts;
      if (!pts.length) continue;
      const labels = (key==="lr") ? ["L1","L2","R1","R2"] : ["T1","T2","B1","B2"];
      const axisSolid = (key==="tb") ? (colors.solidTB||colors.solid) : colors.solid;
      const axisGuide = (key==="tb") ? (colors.guideTB||colors.guide) : colors.guide;
      pts.forEach((p,i)=> drawLabel(p, labels[i], axisSolid));

      if (pts.length>=2){
        const A = imgToScreen(pts[0]);
        const B = imgToScreen(pts[1]);
        drawLine(A,B, axisSolid, 4, null);
        if (showGuides) drawLine(A,B, axisGuide, 2.2, [14,10]);
      }
      if (pts.length>=4){
        const A = imgToScreen(pts[2]);
        const B = imgToScreen(pts[3]);
        drawLine(A,B, axisSolid, 4, null);
        if (showGuides) drawLine(A,B, axisGuide, 2.2, [14,10]);
      }
    }
    } catch (err) {
      try { setToast("Draw error: " + (err && err.message ? err.message : err), 12000); } catch(_){ }
    }

  }

  function clearAxis(axis){
    MS()[axis].pts = [];
    MS()[axis].result = null;
    updateResults();
    syncUI();
    draw();
  }
  function clearAll(){
    clearAxis("lr");
    clearAxis("tb");
  }

  function computeAxis(axis){
    const pts = MS()[axis].pts;
    if (pts.length !== 4) return null;

    // Determine outer/inner pairs by click order as instructed
    // LR: L1 outer left, L2 inner left -> left thickness = |x2-x1|
    //     R1 inner right, R2 outer right -> right thickness = |x4-x3|
    // TB: T1 outer top, T2 inner top -> top thickness = |y2-y1|
    //     B1 inner bottom, B2 outer bottom -> bottom thickness = |y4-y3|
    let aThickness, bThickness;
    if (axis === "lr"){
      aThickness = Math.abs(pts[1].x - pts[0].x);
      bThickness = Math.abs(pts[3].x - pts[2].x);
    } else {
      aThickness = Math.abs(pts[1].y - pts[0].y);
      bThickness = Math.abs(pts[3].y - pts[2].y);
    }

    const total = aThickness + bThickness;
    if (total <= 0.00001) return { ok:false, msg:"Zero thickness" };

    const big = Math.max(aThickness, bThickness) / total * 100;
    const small = 100 - big;

    // Determine which side is bigger
    let bigSide = "";
    if (axis === "lr"){
      bigSide = (aThickness >= bThickness) ? "Left" : "Right";
    } else {
      bigSide = (aThickness >= bThickness) ? "Top" : "Bottom";
    }

    return {
      ok:true,
      a: aThickness,
      b: bThickness,
      big, small,
      bigSide,
      text:
        `${axis.toUpperCase()} border A: ${Math.round(aThickness)} px (raw ${fmt1(aThickness)})\n` +
        `${axis.toUpperCase()} border B: ${Math.round(bThickness)} px (raw ${fmt1(bThickness)})\n` +
        `Split: ${Math.round(big)}/${Math.round(small)} (${bigSide} heavier)`
    };
  }

  // Update the Results panel for the active side
  
  function finishAxisIfReady(axis){
    // Called when the user has placed 4 points for an axis.
    const pts = MS()[axis]?.pts;
    if (!pts || pts.length !== 4) return;

    const res = computeAxis(axis);
    MS()[axis].result = (res && res.ok) ? res : null;

    // Auto-switch to the other axis when one measurement is complete (if the other isn't done yet).
    const other = (axis === "lr") ? "tb" : "lr";
    const otherDone = (MS()[other]?.pts?.length === 4);

    if (!otherDone){
      activeAxis = other;
      // Reset snap smoothing so the new axis doesn't inherit the previous eased point.
      _snapHoverRaw = null;
      _snapHoverSmoothed = null;
    }
    // If both axes are measured, automatically return to colour view by turning off snap-to-border.
    // Users typically only need edge view while placing points.
    const bothDoneNow = (MS().lr?.pts?.length === 4) && (MS().tb?.pts?.length === 4);
    if (bothDoneNow && snapToBorderEnabled){
      snapToBorderEnabled = false;
      if (snapToBorderToggle) snapToBorderToggle.checked = false;
      _invalidateSnapCaches();
    }

    syncUI();
    updateResults();
    updateStatus();
    draw();
  }


  function _setLamp(el, state){
    if (!el) return;
    el.classList.remove("ok","bad");
    if (state === "ok") el.classList.add("ok");
    else if (state === "bad") el.classList.add("bad");
  }

  function _updateGradeLamps(lrRes, tbRes){
    // Lamps are based on the "tightest" side (smaller of the two) for LR and TB.
    // Thresholds are expressed as "smallest side must be >= X%".
    const lamps = [psaLamp, cgcLamp, aceLamp, bgsPristineLamp, cgcPristineLamp].filter(Boolean);

    // Unknown until both axes measured
    if (!lrRes || !tbRes || typeof lrRes.small !== "number" || typeof tbRes.small !== "number"){
      for (const el of lamps) _setLamp(el, "");
      if (gradeHint) gradeHint.textContent = "Measure Left / Right and Top / Bottom to see pass or fail.";
      return;
    }

    const lrSmall = lrRes.small;
    const tbSmall = tbRes.small;

    // Per-side thresholds (front vs back)
    const isBack = (activeSide === "back");
    const t = {
      // PSA Gem Mint 10: 55/45 front, 75/25 back
      psa: isBack ? 25 : 45,
      // CGC Gem Mint 10: 55/45 front, 75/25 back (matches their published guidance)
      cgc: isBack ? 25 : 45,
      // ACE 10: 60/40 on both sides (as requested)
      ace: 40,
      // BGS Pristine 10: 50/50 front, 60/40 back
      bgsP: isBack ? 40 : 50,
      // CGC Pristine 10: 50/50 all around (≈, conservative guide)
      cgcP: 50
    };

    const psaOk  = (lrSmall >= t.psa)  && (tbSmall >= t.psa);
    const cgcOk  = (lrSmall >= t.cgc)  && (tbSmall >= t.cgc);
    const aceOk  = (lrSmall >= t.ace)  && (tbSmall >= t.ace);
    const bgsPOk = (lrSmall >= t.bgsP) && (tbSmall >= t.bgsP);
    const cgcPOk = (lrSmall >= t.cgcP) && (tbSmall >= t.cgcP);

    _setLamp(psaLamp, psaOk ? "ok" : "bad");
    _setLamp(cgcLamp, cgcOk ? "ok" : "bad");
    _setLamp(aceLamp, aceOk ? "ok" : "bad");
    _setLamp(bgsPristineLamp, bgsPOk ? "ok" : "bad");
    _setLamp(cgcPristineLamp, cgcPOk ? "ok" : "bad");

    if (gradeHint){
      const tightest = Math.min(lrSmall, tbSmall);
      gradeHint.textContent =
        `${activeSide.toUpperCase()} tightest side: ${Math.round(tightest)}%. ` +
        `Needs ≥${t.psa}% (PSA), ≥${t.cgc}% (CGC), ≥${t.ace}% (ACE), ` +
        `≥${t.bgsP}% (BGS Pristine), ≥${t.cgcP}% (CGC Pristine≈).`;
    }
  }

	function updateResults(){
    // If no image, reset UI
    if (!currentCanvas){
      if (lrPct) lrPct.textContent = "–";
      if (tbPct) tbPct.textContent = "–";
      if (lrInfo) lrInfo.textContent = "Not measured.";
      if (tbInfo) tbInfo.textContent = "Not measured.";
      _updateGradeLamps(null, null);
      return;
    }

    // Recompute results when a full set of points exists
    for (const axis of ["lr","tb"]){
      const pts = MS()[axis].pts;
      if (pts && pts.length === 4){
        const res = computeAxis(axis);
        MS()[axis].result = (res && res.ok) ? res : null;
      } else {
        MS()[axis].result = null;
      }
    }

    const lrRes = MS().lr.result;
    const tbRes = MS().tb.result;

    if (lrRes && lrRes.ok){
      if (lrPct) lrPct.textContent = `${Math.round(lrRes.big)}/${Math.round(lrRes.small)}`;
      if (lrInfo) lrInfo.textContent = lrRes.text;
    } else {
      if (lrPct) lrPct.textContent = "–";
      if (lrInfo) lrInfo.textContent = "Not measured.";
    }

    if (tbRes && tbRes.ok){
      if (tbPct) tbPct.textContent = `${Math.round(tbRes.big)}/${Math.round(tbRes.small)}`;
      if (tbInfo) tbInfo.textContent = tbRes.text;
    } else {
      if (tbPct) tbPct.textContent = "–";
      if (tbInfo) tbInfo.textContent = "Not measured.";
    }

    _updateGradeLamps(lrRes, tbRes);
  }

// --- Added: line-line intersection helper (required by applyPerspective) ---
function lineIntersection(l1, l2){
  // l1, l2: { a:{x,y}, b:{x,y} }
  const x1 = l1.a.x, y1 = l1.a.y;
  const x2 = l1.b.x, y2 = l1.b.y;
  const x3 = l2.a.x, y3 = l2.a.y;
  const x4 = l2.b.x, y4 = l2.b.y;

  const denom = (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4);
  if (Math.abs(denom) < 1e-6) return null; // parallel or unstable

  const px =
    ((x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4)) / denom;
  const py =
    ((x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4)) / denom;

  return { x: px, y: py };
}

// --- Added: homography + resampling helpers (required by applyPerspective) ---
// Build a homography that maps destination -> source (inverse mapping) so every output pixel can sample a source pixel.
function homographyFrom4(srcPts, dstPts){
  if (!srcPts || !dstPts || srcPts.length !== 4 || dstPts.length !== 4) return null;
  // We want H such that: [x_s, y_s, 1]^T ~ H * [x_d, y_d, 1]^T
  // So solve fromPts = dstPts, toPts = srcPts
  return _solveHomography4(dstPts, srcPts);
}

function _solveHomography4(fromPts, toPts){
  // Solves for 8 unknowns with h33 = 1 using Gaussian elimination.
  // For each correspondence (x,y) -> (u,v):
  // u = (h11 x + h12 y + h13) / (h31 x + h32 y + 1)
  // v = (h21 x + h22 y + h23) / (h31 x + h32 y + 1)
  const A = [];
  const b = [];

  for (let i = 0; i < 4; i++){
    const x = fromPts[i].x, y = fromPts[i].y;
    const u = toPts[i].x,   v = toPts[i].y;

    // u equation
    A.push([ x, y, 1, 0, 0, 0, -u*x, -u*y ]);
    b.push(u);
    // v equation
    A.push([ 0, 0, 0, x, y, 1, -v*x, -v*y ]);
    b.push(v);
  }

  const h = _gaussSolve(A, b);
  if (!h) return null;
  // append h33 = 1
  return [h[0],h[1],h[2], h[3],h[4],h[5], h[6],h[7], 1];
}

function _gaussSolve(A, b){
  // A: n x n, b: n
  const n = A.length;
  if (!n || A[0].length !== n || b.length !== n) return null;

  // build augmented matrix
  const M = new Array(n);
  for (let i = 0; i < n; i++){
    M[i] = A[i].slice();
    M[i].push(b[i]);
  }

  for (let col = 0; col < n; col++){
    // find pivot
    let pivot = col;
    let maxAbs = Math.abs(M[col][col]);
    for (let row = col + 1; row < n; row++){
      const v = Math.abs(M[row][col]);
      if (v > maxAbs){
        maxAbs = v;
        pivot = row;
      }
    }
    if (maxAbs < 1e-10) return null; // singular/unstable

    // swap
    if (pivot !== col){
      const tmp = M[col]; M[col] = M[pivot]; M[pivot] = tmp;
    }

    // normalize pivot row
    const pv = M[col][col];
    for (let j = col; j <= n; j++) M[col][j] /= pv;

    // eliminate other rows
    for (let row = 0; row < n; row++){
      if (row === col) continue;
      const f = M[row][col];
      if (Math.abs(f) < 1e-12) continue;
      for (let j = col; j <= n; j++){
        M[row][j] -= f * M[col][j];
      }
    }
  }

  // extract solution
  const x = new Array(n);
  for (let i = 0; i < n; i++) x[i] = M[i][n];
  return x;
}

function applyHomography(H, x, y){
  // H: [h11,h12,h13,h21,h22,h23,h31,h32,h33]
  const den = H[6]*x + H[7]*y + H[8];
  if (Math.abs(den) < 1e-12) return { x: 0, y: 0 };
  return {
    x: (H[0]*x + H[1]*y + H[2]) / den,
    y: (H[3]*x + H[4]*y + H[5]) / den
  };
}

function sampleBilinear(imgData, w, h, x, y){
  // Returns [r,g,b,a] bilinearly sampled from ImageData.
  // Outside image => transparent.
  if (!imgData || !imgData.data) return [0,0,0,0];
  if (x < 0 || y < 0 || x > (w - 1) || y > (h - 1)) return [0,0,0,0];

  const x0 = Math.floor(x);
  const y0 = Math.floor(y);
  const x1 = Math.min(w - 1, x0 + 1);
  const y1 = Math.min(h - 1, y0 + 1);

  const dx = x - x0;
  const dy = y - y0;

  const d = imgData.data;
  const i00 = (y0*w + x0) * 4;
  const i10 = (y0*w + x1) * 4;
  const i01 = (y1*w + x0) * 4;
  const i11 = (y1*w + x1) * 4;

  const out = [0,0,0,0];
  for (let c = 0; c < 4; c++){
    const v00 = d[i00 + c];
    const v10 = d[i10 + c];
    const v01 = d[i01 + c];
    const v11 = d[i11 + c];

    const v0 = v00 + (v10 - v00) * dx;
    const v1 = v01 + (v11 - v01) * dx;
    out[c] = Math.round(v0 + (v1 - v0) * dy);
  }
  return out;
}




  

  

  function applyPerspective(){
    if (perspLines.length !== 4 || perspTemp) return;
    const top = perspLines[0], right = perspLines[1], bottom = perspLines[2], left = perspLines[3];

// Auto-rotate using the LEFT border line so it becomes vertical before perspective warp.
// This makes the perspective correction also straighten the card.
const lc = left.a, ld = left.b;
const angLeft = Math.atan2(ld.y - lc.y, ld.x - lc.x);   // left edge direction
const rot = (Math.PI / 2) - angLeft;                    // rotate onto vertical
const cosR = Math.cos(rot), sinR = Math.sin(rot);
const cx = imgW/2, cy = imgH/2;

function rotPt(p){
  const x = p.x - cx, y = p.y - cy;
  return { x: (x*cosR - y*sinR) + cx, y: (x*sinR + y*cosR) + cy };
}

// Rotate the source image into a temporary canvas (same dimensions)
const rotC = document.createElement("canvas");
rotC.width = imgW; rotC.height = imgH;
const rctx = rotC.getContext("2d");
rctx.clearRect(0,0,imgW,imgH);
rctx.save();
rctx.translate(cx,cy);
rctx.rotate(rot);
rctx.translate(-cx,-cy);
rctx.drawImage(currentCanvas,0,0);
rctx.restore();

// Rotate the captured border lines into the same coordinate space
const topR    = { a: rotPt(top.a),    b: rotPt(top.b)    };
const rightR  = { a: rotPt(right.a),  b: rotPt(right.b)  };
const bottomR = { a: rotPt(bottom.a), b: rotPt(bottom.b) };
const leftR   = { a: rotPt(left.a),   b: rotPt(left.b)   };
    const TL = lineIntersection(topR, leftR);
    const TR = lineIntersection(topR, rightR);
    const BR = lineIntersection(bottomR, rightR);
    const BL = lineIntersection(bottomR, leftR);
    if (!TL || !TR || !BR || !BL){
      setToast("Could not intersect lines. Try again.");
      return;
    }
    const dist = (p,q)=>Math.hypot(p.x-q.x, p.y-q.y);
    const w0 = dist(TL, TR), w1 = dist(BL, BR);
    const h0 = dist(TL, BL), h1 = dist(TR, BR);

    let wRect = (w0 + w1)/2;
    let hRect = (h0 + h1)/2;
    if (wRect < 10 || hRect < 10){
      setToast("Lines too close. Draw longer lines.");
      return;
    }

    // Constrain to Pokémon aspect ratio using both estimates
    const wFromH = hRect / POKEMON_AR;
    const Wcard = (wRect + wFromH)/2;
    const Hcard = Wcard * POKEMON_AR;
    wRect = Wcard;
    hRect = Hcard;

    // Fit rect into the existing image dimensions (keep full output canvas size)
    const scale = 0.95 * Math.min(imgW / wRect, imgH / hRect);
    const W = wRect * scale;
    const H = hRect * scale;
    const ox = (imgW - W)/2;
    const oy = (imgH - H)/2;

    const dstPts = [
      {x: ox,   y: oy},
      {x: ox+W, y: oy},
      {x: ox+W, y: oy+H},
      {x: ox,   y: oy+H},
    ];
    const srcPts = [TL, TR, BR, BL];

    const Hmap = homographyFrom4(srcPts, dstPts);
    if (!Hmap){
      setToast("Perspective solve failed. Try again.");
      return;
    }

    // read source pixels
    const sctx = rotC.getContext("2d", {willReadFrequently:true});
    const srcImg = sctx.getImageData(0,0,imgW,imgH);

    const outC = document.createElement("canvas");
    outC.width = imgW; outC.height = imgH;
    const octx = outC.getContext("2d", {willReadFrequently:true});
    const outImg = octx.createImageData(imgW, imgH);

    for (let y=0;y<imgH;y++){
      for (let x=0;x<imgW;x++){
        const p = applyHomography(Hmap, x, y);
        const rgba = sampleBilinear(srcImg, imgW, imgH, p.x, p.y);
        const i = (y*imgW + x)*4;
        outImg.data[i+0]=rgba[0];
        outImg.data[i+1]=rgba[1];
        outImg.data[i+2]=rgba[2];
        outImg.data[i+3]=rgba[3];
      }
    }
    octx.putImageData(outImg,0,0);
    currentCanvas = outC;

    geomCapturing = false;
    perspLines = [];
    perspTemp = null;

    // Store the exact outer rectangle we mapped the card into.
    // This is "known truth" from the perspective step and is used for measurement.
    setPerspRect(activeSide, { ox, oy, W, H });

    // Always clear previous manual measurements after a geometry warp
    clearAll();
    centreImage();

    // Optional one-click measurement is available after perspective.
    // Users can still measure manually.
    setToast("Perspective applied. Click measurement, or measure manually.");

    saveActiveSide();
    syncUI();
    draw();
  }

  // ---------- Input: upload/reset/export ----------
  uploadBtn.addEventListener("click", ()=> fileInput.click());
  fileInput.addEventListener("change", async (e)=>{
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{
      try{
      fileInput.value = "";

      imgW = img.naturalWidth; saveActiveSide();
      imgH = img.naturalHeight;

      baseCanvas = document.createElement("canvas");
      baseCanvas.width = imgW; baseCanvas.height = imgH;
      baseCanvas.getContext("2d", { willReadFrequently: true }).drawImage(img,0,0);

      currentCanvas = document.createElement("canvas");
      currentCanvas.width = imgW; currentCanvas.height = imgH;
      currentCanvas.getContext("2d", { willReadFrequently: true }).drawImage(img,0,0);

      URL.revokeObjectURL(url);
      zoom = 1; panX = 0; panY = 0;
      geomModeSel.value = "none";
      geomMode = "none";
      geomCapturing = false;
      rotPts = [];
      perspLines = []; perspTemp = null;

      clearAll();
      activeAxis = "lr";
      centreImage();
      resize();
      syncUI();
      saveActiveSide();
      setToast(`Image loaded (${activeSide}): ${imgW}×${imgH}`);
      _invalidateSnapCaches();
      draw();
      }catch(err){
        console.error(err);
        setToast("Load failed: " + (err && err.message ? err.message : "unknown"));
      }
    };
    img.onerror = (e)=> { console.error(e); setToast("Could not load image."); };
    img.src = url;
  });

  resetBtn.addEventListener("click", ()=>{
    _invalidateSnapCaches();
    saveActiveSide();
    if (!baseCanvas) return;
    currentCanvas = document.createElement("canvas");
    currentCanvas.width = imgW; currentCanvas.height = imgH;
    currentCanvas.getContext("2d", { willReadFrequently: true }).drawImage(baseCanvas,0,0);
    geomMode = "none";
    geomModeSel.value = "none";
    geomCapturing = false;
    rotPts = [];
    perspLines = []; perspTemp = null;
    clearAll();
    activeAxis = "lr";
    centreImage();
    syncUI();
    draw();
    setToast("Reset.");
  });


  // (Removed broken legacy single-side export block)
  // ---------- Geometry UI ----------
  // Auto-start geometry capture when a mode is selected (no separate Start button)
  geomModeSel.addEventListener("change", ()=>{
    geomMode = geomModeSel.value;

    // Always reset any in-progress capture when switching modes
    rotPts = [];
    perspLines = [];
    perspTemp = null;

    if (!currentCanvas || geomMode === "none"){
      // None selected (or no image loaded): ensure capture is off
      geomCapturing = false;
    } else {
      // Mode selected: start capture immediately
      geomCapturing = true;
      setToast(`Geometry: ${geomMode === "rotate" ? "Rotate" : "Perspective"} capture started.`);
    }

    syncUI();
    draw();
  });


  geomCancel.addEventListener("click", ()=>{
    geomCapturing = false;
    rotPts = [];
    perspLines = []; perspTemp = null;
    setToast("Cancelled.");
    syncUI();
    draw();
  });
  geomApply.addEventListener("click", ()=>{
    if (geomMode === "rotate") applyRotate();
    else if (geomMode === "persp") applyPerspective();
  });

  // ---------- Measure UI ----------
  measureLR.addEventListener("click", ()=>{ activeAxis="lr"; syncUI(); draw(); });
  measureTB.addEventListener("click", ()=>{ activeAxis="tb"; syncUI(); draw(); });
  clearMarks.addEventListener("click", ()=>{ clearAxis(activeAxis); setToast("Cleared selected."); });
  clearMarksAll.addEventListener("click", ()=>{ clearAll(); setToast("Cleared all measurements."); });

  // Undo and reset axis
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "u"){
      const pts = MS()[activeAxis].pts;
      if (pts.length){
        pts.pop();
        MS()[activeAxis].result = null;
        updateResults();
        syncUI();
        draw();
      }
    }
    if (k === "r"){
      clearAxis(activeAxis);
    }
  });

  // ---------- Pointer interactions: pinch zoom, pan, clicks ----------
  function setZoomAround(newZoom, anchorX, anchorY){
    newZoom = clamp(newZoom, 0.10, 24.0);
    const before = screenToImg(anchorX, anchorY);
    zoom = newZoom;
    // Keep the anchor point stable
    panX = anchorX - before.x * zoom;
    panY = anchorY - before.y * zoom;
    updateZoomPill();
    draw();
  }
  function centerViewOnImgPoint(imgPt){
    const r = wrap.getBoundingClientRect();
    const cx = r.width/2;
    const cy = r.height/2;
    panX = cx - imgPt.x * zoom;
    panY = cy - imgPt.y * zoom;
  }

  function autoJumpAfterSecondClick(axis){
    // Auto jump intentionally disabled in v7.3.17 clean branch.
    return;
    
}


  wrap.addEventListener("wheel", (e)=>{
  if (!currentCanvas) return;
  e.preventDefault();

  const r = wrap.getBoundingClientRect();
  const sx = e.clientX - r.left;
  const sy = e.clientY - r.top;

  // Heuristic: trackpads usually produce small, smooth deltas (often with deltaX too).
  // Mouse wheels usually produce larger "chunky" deltaY steps.
  const isLikelyTrackpad =
    e.deltaMode === 0 && (
      Math.abs(e.deltaX) > 0 ||
      Math.abs(e.deltaY) < 50
    );

  // Trackpad pinch zoom commonly shows as wheel + ctrlKey
  if (e.ctrlKey) {
    const factor = Math.exp(-e.deltaY * 0.0048);
    setZoomAround(zoom * factor, sx, sy);
    return;
  }

  // Keep two-finger trackpad scrolling as PAN
  if (isLikelyTrackpad) {
    panX -= e.deltaX;
    panY -= e.deltaY;
    draw();
    return;
  }

  // Mouse wheel = ZOOM
  const factor = Math.exp(-e.deltaY * 0.0025);
  setZoomAround(zoom * factor, sx, sy);
}, { passive:false });
// Mouse hover updates for preview lines (pointermove only fires when a pointer is tracked).
  wrap.addEventListener("mousemove", (e)=>{
    if (!currentCanvas) return;
    const r = wrap.getBoundingClientRect();
    const sx = e.clientX - r.left;
    const sy = e.clientY - r.top;
    const raw = screenToImg(sx, sy);
    pointerImgPt = raw.inBounds ? { x: raw.x, y: raw.y } : null;
    draw();
  });

  wrap.addEventListener("mouseleave", ()=>{
    pointerImgPt = null;
    hoverImgPt = null;
    _snapHoverRaw = null;
    _snapHoverSmoothed = null;
    draw();
  });

  wrap.addEventListener("pointerdown", (e)=>{
    wrap.setPointerCapture(e.pointerId);
    const r = wrap.getBoundingClientRect();
    const sx = e.clientX - r.left;
    const sy = e.clientY - r.top;
    pointers.set(e.pointerId, {x:sx,y:sy,type:e.pointerType,buttons:e.buttons});

    // Middle mouse panning
    if (e.pointerType === "mouse" && e.button === 1){
      isMiddlePanning = true;
      middlePanStart = { x:sx, y:sy, panX, panY };
      return;
    }

    // If we have 2 pointers, initialise pinch
    if (pointers.size === 2){
      const pts = Array.from(pointers.values());
      pinchStartDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      pinchStartZoom = zoom;
      pinchStartPanX = panX;
      pinchStartPanY = panY;
      pinchStartCenter = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };
    }
  });

  wrap.addEventListener("pointermove", (e)=>{
    if (!pointers.has(e.pointerId)) return;
    const r = wrap.getBoundingClientRect();
    const sx = e.clientX - r.left;
    const sy = e.clientY - r.top;
    pointers.set(e.pointerId, {x:sx,y:sy,type:e.pointerType,buttons:e.buttons});

    if (!currentCanvas) return;

    // Update hover point for locked previews (only when not pinching and not middle-panning)
    if (!isMiddlePanning && pointers.size < 2) {
      const raw = screenToImg(sx, sy);
      if (raw.inBounds) {
        hoverImgPt = { x: raw.x, y: raw.y };
        pointerImgPt = { x: raw.x, y: raw.y };
      } else {
        hoverImgPt = null;
        pointerImgPt = null;
      }
    }

    if (isMiddlePanning){
      panX = middlePanStart.panX + (sx - middlePanStart.x);
      panY = middlePanStart.panY + (sy - middlePanStart.y);
      draw();
      return;
    }

    // Pinch zoom + two-finger pan
    if (pointers.size === 2){
      const pts = Array.from(pointers.values());
      const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      const center = { x: (pts[0].x + pts[1].x)/2, y: (pts[0].y + pts[1].y)/2 };

      // Always allow two-finger PAN (centroid movement)
      panX = pinchStartPanX + (center.x - pinchStartCenter.x);
      panY = pinchStartPanY + (center.y - pinchStartCenter.y);

      // Only apply ZOOM if the pinch distance actually changed meaningfully.
      const distDelta = Math.abs(dist - pinchStartDist);
      const zoomThresholdPx = 3;           // ignore tiny finger jitter (snappier)
      const zoomThresholdRel = 0.006;      // or ~0.6% change (snappier)
      const relDelta = (pinchStartDist > 0.001) ? distDelta / pinchStartDist : 0;

      if (pinchStartDist > 0.001 && (distDelta > zoomThresholdPx || relDelta > zoomThresholdRel)){
        const factorRaw = dist / pinchStartDist;
        const factor = Math.pow(factorRaw, 1.7);
        const newZoom = pinchStartZoom * factor;

        // Keep centroid stable in image space
        const before = screenToImg(center.x, center.y);
        zoom = clamp(newZoom, 0.08, 24.0);
        panX = center.x - before.x * zoom;
        panY = center.y - before.y * zoom;
        updateZoomPill();
      }

      draw();
      return;
    }
  });

  wrap.addEventListener("pointerup", (e)=>{
    if (e.pointerType === "mouse" && e.button === 1){
      isMiddlePanning = false;
    }
    pointers.delete(e.pointerId);
    if (pointers.size < 2){
      pinchStartDist = 0;
    }
    if (pointers.size === 0) { hoverImgPt = null; pointerImgPt = null; }
  });

  wrap.addEventListener("pointercancel", (e)=>{
    pointers.delete(e.pointerId);
    isMiddlePanning = false;
    pinchStartDist = 0;
    hoverImgPt = null;
  });

  // Click to add points (ignore if pinch or middle pan or geom capture is off?)
  wrap.addEventListener("click", (e)=>{
    if (!currentCanvas) return;
    // Avoid click events after middle button pan or pinch
    if (isMiddlePanning) return;
    if (pointers.size >= 2) return;
    // ignore click if it's middle button
    if (e.button === 1) return;

    const r = wrap.getBoundingClientRect();
    const sx = e.clientX - r.left;
    const sy = e.clientY - r.top;

    const raw0 = screenToImg(sx, sy);
    if (!raw0.inBounds){
      setToast("Click was outside the image. Pan/zoom and click on the card.");
      return;
    }
    const raw = { x: raw0.x, y: raw0.y };

    // Geometry capture routing
    if (geomCapturing){
      if (geomMode === "rotate"){
        if (rotPts.length >= 2) return;
        rotPts.push(raw);
        syncUI(); draw();
        return;
      }
      if (geomMode === "persp"){
        if (perspLines.length >= 4 && !perspTemp) return;
        if (!perspTemp){
          perspTemp = raw;
        } else {
          perspLines.push({ a: perspTemp, b: raw });
          perspTemp = null;
        }
        syncUI(); draw();
        return;
      }
      return;
    }

    // Measurement mode
    const pts = MS()[activeAxis].pts;
    if (pts.length >= 4) return;

    // Optional: snap click to a likely border edge (toggleable)
    const anchor = (pts.length >= 1) ? pts[0] : null;
    let raw2 = raw;
    if (snapToBorderEnabled){
      // For LR we search along X at the anchored Y. For TB we search along Y at the anchored X.
      const constrained = anchor ? projectToAxis(anchor, raw, activeAxis) : raw;
      const snappedNow = snapPointToBorder(constrained, activeAxis, anchor || constrained);

      // Prefer the smoothed hover snap if it's available and very close to this click location,
      // so the committed point matches what the user visually saw.
      if (_snapHoverSmoothed){
        const dd = Math.hypot(_snapHoverSmoothed.x - snappedNow.x, _snapHoverSmoothed.y - snappedNow.y);
        if (dd <= 8){
          raw2 = { x: _snapHoverSmoothed.x, y: _snapHoverSmoothed.y };
        } else {
          raw2 = snappedNow;
        }
      } else {
        raw2 = snappedNow;
      }
    }

    // Snap ALL subsequent clicks to the axis defined by the first click for this measurement set.
    let snapped = raw2;
    if (pts.length >= 1) {
      snapped = projectToAxis(pts[0], raw2, activeAxis);
    }
// If user switches axis mid-way, that's allowed
    pts.push(snapped);
    MS()[activeAxis].result = null;

    // After the 2nd click (first edge complete), jump view to the estimated opposite edge
    if (pts.length === 2){
      autoJumpAfterSecondClick(activeAxis);
    }

    if (pts.length === 4){
      finishAxisIfReady(activeAxis);
    } else {
      syncUI();
      draw();
    }
  });

  
  // Init
  resize();
  syncUI();
  updateResults();


  // ===== SAFE PDF EXPORT (DOM-based, parser-proof) =====
  exportBtn.addEventListener("click", ()=>{
    const f = measureSides.front;
    const b = measureSides.back;

    const frontReady = !!(sides.front.currentCanvas && f.lr.result && f.tb.result);
    const backReady  = !!(sides.back.currentCanvas  && b.lr.result && b.tb.result);

    if (!frontReady && !backReady) {
      setToast("Measure Front or Back before exporting.");
      return;
    }

    const w = window.open("", "_blank");
    if (!w){
      setToast("Popup blocked. Allow popups to export.");
      return;
    }

    const d = w.document;
    d.open();

    const html = d.createElement("html");
    const head = d.createElement("head");
    const body = d.createElement("body");

    const meta = d.createElement("meta");
    meta.setAttribute("charset","utf-8");
    head.appendChild(meta);

    const style = d.createElement("style");
    style.textContent =
      "body{font-family:system-ui,ui-sans-serif;margin:20px;color:#111;}" +
      "h1{margin:0 0 6px 0;} h2{margin:18px 0 6px 0;}" +
      ".meta{font-size:12px;color:#555;margin-bottom:12px;}" +
      ".page{page-break-after:always;}" +
      ".page:last-child{page-break-after:auto;}" +
      "img{width:100%;max-height:65vh;object-fit:contain;border:1px solid #ddd;border-radius:12px;}" +
      ".grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px;}" +
      ".box{border:1px solid #ddd;border-radius:12px;padding:12px;}" +
      ".label{font-size:11px;letter-spacing:.14em;text-transform:uppercase;color:#666;font-weight:800;}" +
      ".val{font-size:20px;font-weight:900;margin-top:6px;}" +
      ".small{font-size:12px;white-space:pre-line;color:#444;}" +
      "@media print{body{margin:12mm;} img{max-height:150mm;}}";
    head.appendChild(style);

    // --- Render an "annotated" image for the PDF (reported issue: overlay lines missing) ---
    // The on-screen overlays are drawn to the VIEW canvas in screen coords.
    // The PDF export embeds s.currentCanvas only, which contains *no overlays*.
    // Fix: build a temporary image-space canvas and draw the measurement overlays onto it.
    function annotatedDataURL(sideKey){
      const s = sides[sideKey];
      const m = measureSides[sideKey];
      if (!s || !s.currentCanvas) return "";

      const src = s.currentCanvas;
      const out = document.createElement("canvas");
      out.width = src.width;
      out.height = src.height;

      const c = out.getContext("2d");
      c.drawImage(src, 0, 0);

      const colors = {
        lr: "rgba(49,199,255,1)",
        tb: "rgba(255,165,0,1)"
      };

      function drawLineImg(a,b,color,width=4,dash=null){
        c.save();
        c.strokeStyle = color;
        c.lineWidth = width;
        c.lineCap = "round";
        c.lineJoin = "round";
        if (dash) c.setLineDash(dash);
        c.shadowColor = color;
        c.shadowBlur = dash ? 3 : 10;
        c.beginPath();
        c.moveTo(a.x, a.y);
        c.lineTo(b.x, b.y);
        c.stroke();
        c.restore();
      }

      function drawLabelImg(p, text, color){
        const fs = Math.max(14, Math.round(Math.min(out.width, out.height) / 55));
        c.save();
        c.font = `900 ${fs}px ui-sans-serif, system-ui`;
        c.textBaseline = "middle";
        c.textAlign = "center";
        // shadow/outline for readability
        c.fillStyle = "rgba(0,0,0,0.55)";
        c.fillText(text, p.x+1, p.y+fs+1);
        c.fillStyle = color;
        c.fillText(text, p.x, p.y+fs);
        c.restore();
      }

      function drawAxis(axisKey){
        const axis = m[axisKey];
        if (!axis || !axis.pts || axis.pts.length === 0) return;

        const col = (axisKey === "tb") ? colors.tb : colors.lr;
        const labels = (axisKey === "tb")
          ? ["T1","T2","B1","B2"]
          : ["L1","L2","R1","R2"];

        axis.pts.forEach((pt, i)=>{
          drawLabelImg(pt, labels[i] || String(i+1), col);
        });

        // Draw the two measured segments (outer->inner on one side, inner->outer on the other)
        if (axis.pts.length >= 2){
          drawLineImg(axis.pts[0], axis.pts[1], col, 5, null);
        }
        if (axis.pts.length >= 4){
          drawLineImg(axis.pts[2], axis.pts[3], col, 5, null);
        }
      }

      drawAxis("lr");
      drawAxis("tb");

      return out.toDataURL("image/png");
    }

    function buildPage(sideKey, label){
      const s = sides[sideKey];
      const m = measureSides[sideKey];

      const page = d.createElement("div");
      page.className = "page";

      const h = d.createElement("h2");
      h.textContent = label;
      page.appendChild(h);

      const img = d.createElement("img");
      img.src = annotatedDataURL(sideKey);
      page.appendChild(img);

      const grid = d.createElement("div");
      grid.className = "grid";

      function box(title, res){
        const b = d.createElement("div");
        b.className = "box";
        const l = d.createElement("div");
        l.className = "label";
        l.textContent = title;
        const v = d.createElement("div");
        v.className = "val";
        v.textContent = Math.round(res.big) + "/" + Math.round(res.small);
        const t = d.createElement("div");
        t.className = "small";
        t.textContent = res.text;
        b.appendChild(l); b.appendChild(v); b.appendChild(t);
        return b;
      }

      grid.appendChild(box("Left / Right", m.lr.result));
      grid.appendChild(box("Top / Bottom", m.tb.result));
      page.appendChild(grid);
      // Grading guidance (centering only)
      const g = d.createElement("div");
      g.className = "meta";
      const sideLabel = (sideKey === "back") ? "Back" : "Front";
      const t = (sideKey === "back")
        ? { psa:"75/25", cgc:"75/25", ace:"60/40", bgsP:"60/40", cgcP:"50/50 (≈)" }
        : { psa:"55/45", cgc:"55/45", ace:"60/40", bgsP:"50/50", cgcP:"50/50" };

      const lrSmall = m.lr.result.small;
      const tbSmall = m.tb.result.small;
      const tightest = Math.min(lrSmall, tbSmall);

      function pass(minSmall){ return (lrSmall >= minSmall) && (tbSmall >= minSmall); }

      const psaMin  = (sideKey === "back") ? 25 : 45;
      const cgcMin  = (sideKey === "back") ? 25 : 45;
      const aceMin  = 40;
      const bgsPMin = (sideKey === "back") ? 40 : 50;
      const cgcPMin = 50;

      g.innerHTML =
        `<div style="font-weight:900;margin-top:10px;">10 centring guidance (${sideLabel})</div>` +
        `<div style="margin-top:6px;">Tightest side: <b>${Math.round(tightest)}%</b></div>` +
        `<div style="margin-top:6px;">` +
          `PSA 10 (${t.psa}) — <b>${pass(psaMin) ? "PASS" : "FAIL"}</b><br/>` +
          `CGC 10 (${t.cgc}) — <b>${pass(cgcMin) ? "PASS" : "FAIL"}</b><br/>` +
          `ACE 10 (${t.ace}) — <b>${pass(aceMin) ? "PASS" : "FAIL"}</b><br/>` +
          `BGS Pristine 10 (${t.bgsP}) — <b>${pass(bgsPMin) ? "PASS" : "FAIL"}</b><br/>` +
          `CGC Pristine 10 (${t.cgcP}) — <b>${pass(cgcPMin) ? "PASS" : "FAIL"}</b>` +
        `</div>` +
        `<div style="margin-top:10px;font-size:11px;color:#666;">Disclaimer: This aims to estimate centring as accurately as possible, but results depend on image quality and it can’t account for lens distortion, perspective warp, or bent or warped cards.</div>`;
      page.appendChild(g);


      return page;
    }

    const title = d.createElement("h1");
    title.textContent = "Card Centering Measurement";
    body.appendChild(title);

    const info = d.createElement("div");
    info.className = "meta";
    info.textContent = "Exported: " + new Date().toLocaleString() + " | Aspect ratio: 63x88 mm";
    body.appendChild(info);

    if (frontReady) body.appendChild(buildPage("front","Front"));
    if (backReady)  body.appendChild(buildPage("back","Back"));
html.appendChild(head);
    html.appendChild(body);
    d.appendChild(html);
    d.close();

    w.onload = ()=>setTimeout(()=>w.print(), 300);
  });


})();
</script>
</body>
</html>
